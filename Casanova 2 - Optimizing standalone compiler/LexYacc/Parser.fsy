  %{
#nowarn "1182"  // generated code has lots of unused "parseState"   
#nowarn "62"
open Microsoft.FSharp.Text.Parsing
open System
open Microsoft.FSharp.Text.Lexing
open Microsoft.FSharp.Compiler.ErrorLogger
open Internals.Utils
open CasanovaCompiler.ParseAST

type Position = Microsoft.FSharp.Text.Lexing.Position

let printfn (s : string) = System.Console.WriteLine(s)

#if DEBUG
let debugPrint(s) =
    //if Internal.Utilities.Text.Parsing.Flags.debug then 
        printfn s
#else
let debugPrint(s) = ignore s 
#endif


let isSome x = match x with None -> false | _ -> true
let patFromParseError (e:SynPat) = SynPat.FromParseError(e, e.Range)
let isNone x = match x with None -> true | _ -> false
let frontAndBack l = 
  let rec loop acc l = 
    match l with
    | [] -> 
      System.Diagnostics.Debug.Assert(false, "empty list")
      invalidArg "l" "empty list" 
    | [h] -> List.rev acc,h
    | h::t -> loop  (h::acc) t
  loop [] l
let isNil x = match x with [] -> true | _ -> false
let nonNil x = match x with [] -> false | _ -> true
let rec last l = match l with [] -> failwith "last" | [h] -> h | _::t -> last t
let isUpper (s:string) = 
    s.Length >= 1 && System.Char.IsUpper s.[0] && not (System.Char.IsLower s.[0])
let isNull (x : 'T) = match (x :> obj) with null -> true | _ -> false
let isNonNull (x : 'T) = match (x :> obj) with null -> false | _ -> true
let nonNull msg x = if isNonNull x then x else failwith ("null: " ^ msg) 
let mkRange f b e = b
let IsValidPrefixOperatorUse s = 
    match s with 
    | "?+" | "?-" | "+" | "-" | "+." | "-." | "%" | "%%" | "&" | "&&" -> true
    | _ -> s.[0] = '!' || (s.[0] = '~' && String.forall (fun c -> c = s.[0]) s)
    
let IsValidPrefixOperatorDefinitionName s = 
    match s with 
    | "~?+" | "~?-" | "~+" | "~-" | "~+." | "~-." | "~%" | "~%%" | "~&" | "~&&" -> true
    | _ -> (s.[0] = '!' && s <> "!=") || (s.[0] = '~' && String.forall (fun c -> c = s.[0]) s)
        
let MangledGlobalName = "`global`"

let opNameCons = CompileOpName "::"
let opNameNil = CompileOpName "[]"
let opNameEquals = CompileOpName "="
let opNameEqualsNullable = CompileOpName "=?"
let opNameNullableEquals = CompileOpName "?="
let opNameNullableEqualsNullable = CompileOpName "?=?"
let mkSynOptionalExpr m xopt = 
    match xopt with 
    | None -> mkSynLidGet m [] "None"
    | Some x  -> SynExpr.App(ExprAtomicFlag.NonAtomic, false, mkSynLidGet m [] "Some",x,m)



let mkUnderscoreRecdField m = LongIdentWithDots([ident("_", m)], []), false


let mkSynDoBinding (strict,expr,m) = 
    Binding ((if strict then SynPat.Const(SynConst.Unit,m) else SynPat.Wild m),
             expr,SynInfo.emptySynValData, m)



let rebindRanges first fields lastSep = 
    let rec run (name, value) l acc = 
        match l with
        | [] -> List.rev ((name, value, lastSep)::acc)
        | (f, m)::xs -> run f xs ((name, value, m)::acc)
    run first fields []

let reportParseErrorAt m s = errorR(Error(s,m))

let unionRangeWithPos (r:Position) p = r

let raiseParseErrorAt m s = 
    reportParseErrorAt m s; 
    // This initiates error recovery
    raise RecoverableParseError 

let checkEndOfFileError t = 
  match t with 
  | LexCont.IfDefSkip(_,_,m)                      -> reportParseErrorAt m (FSComp.SR.parsEofInHashIf())
  | LexCont.String (_,m)                          -> reportParseErrorAt m (FSComp.SR.parsEofInString())
  | LexCont.TripleQuoteString (_,m)               -> reportParseErrorAt m (FSComp.SR.parsEofInTripleQuoteString())
  | LexCont.VerbatimString (_,m)                  -> reportParseErrorAt m (FSComp.SR.parsEofInVerbatimString())
  | LexCont.Comment (_,_,m)                       -> reportParseErrorAt m (FSComp.SR.parsEofInComment())
  | LexCont.SingleLineComment (_,_,m)             -> reportParseErrorAt m (FSComp.SR.parsEofInComment())
  | LexCont.StringInComment (_,_,m)               -> reportParseErrorAt m (FSComp.SR.parsEofInStringInComment())
  | LexCont.VerbatimStringInComment (_,_,m)       -> reportParseErrorAt m (FSComp.SR.parsEofInVerbatimStringInComment())
  | LexCont.TripleQuoteStringInComment (_,_,m)    -> reportParseErrorAt m (FSComp.SR.parsEofInTripleQuoteStringInComment())
  | LexCont.MLOnly (_,m)                          -> reportParseErrorAt m (FSComp.SR.parsEofInIfOcaml())
  | LexCont.EndLine(LexerEndlineContinuation.Skip(_,_,m)) -> reportParseErrorAt m (FSComp.SR.parsEofInDirective())
  | LexCont.EndLine(LexerEndlineContinuation.Token(stack))
  | LexCont.Token(stack) -> 
      match stack with 
      | [] -> ()
      | (_,m) :: _  -> reportParseErrorAt m (FSComp.SR.parsNoHashEndIfFound())

//                BindingSetPreAttrs(letRange, isRec, isUse, builderFunction, wholeRange,_)
//type BindingSet = BindingSetPreAttrs of Position * bool * bool *  SynBinding list * Position

let rec split pred l =
    match l with
    | [] -> [],[]
    | x :: xs ->
        let res1,res2 = split pred xs
        if pred x then
            (x :: res1),res2
        else
            res1,(x :: res2)

let mkLocalBindings (mWhole,BindingSetPreAttrs(_,isRec,isUse,declsPreAttrs,_,is_wait),body) = 
   let decls = declsPreAttrs
   SynExpr.LetOrBindingOrUse (isRec,isUse,is_wait,decls,body,mWhole) 

let mkDefnBindings (mWhole,BindingSetPreAttrs(_,isRec,isUse,declsPreAttrs,_bindingSetRange,_),attrs,vis,attrsm) = 
    []

let idOfPat m p = 
    match p with 
    | SynPat.LongIdent(LongIdentWithDots([id],_),_,_,_) -> id
    | _ -> raiseParseErrorAt m (FSComp.SR.parsIntegerForLoopRequiresSimpleIdentifier())

let checkForMultipleAugmentations m a1 a2 = 
    if nonNil a1 && nonNil a2 then raiseParseErrorAt m (FSComp.SR.parsOnlyOneWithAugmentationAllowed());
    a1 @ a2

let unionRangeWithListBy projectRangeFromThing m listOfThing = 
    (m, listOfThing) ||> List.fold (fun m thing -> unionRanges m (projectRangeFromThing thing))

let rangeOfLongIdent(lid:LongIdent) =
    System.Diagnostics.Debug.Assert(not lid.IsEmpty, "the parser should never produce a long-id that is the empty list") 
    (lid.Head.idRange,lid) ||> unionRangeWithListBy (fun id -> id.idRange) 

%}      
  
%token A B C 
 

 
%token <byte[]> BYTEARRAY
%token <string> STRING 
%token <string> KEYWORD_STRING // Like __SOURCE_DIRECTORY__
%token <string> IDENT 
%token <string> INFIX_STAR_STAR_OP 
%token <string> INFIX_COMPARE_OP 
%token <string> INFIX_AT_HAT_OP 
%token <string> INFIX_BAR_OP 
%token <string> PREFIX_OP
%token <string> INFIX_STAR_DIV_MOD_OP 
%token <string> INFIX_AMP_OP 
%token <string> PLUS_MINUS_OP 
%token <string> ADJACENT_PREFIX_OP 
%token <string> FUNKY_OPERATOR_NAME

/* bool indicates if INT8 was 'bad' max_int+1, e.g. '128'  */
%token <sbyte * bool> INT8 
%token <int16 * bool> INT16
%token <int32 * bool> INT32 INT32_DOT_DOT
%token <int64 * bool> INT64

%token <byte> UINT8
%token <uint16> UINT16
%token <uint32> UINT32
%token <uint64> UINT64
%token <uint64> UNATIVEINT
%token <int64> NATIVEINT
%token <single> IEEE32
%token <double> IEEE64
%token <char> CHAR
%token <System.Decimal> DECIMAL 
%token <(string * string)> BIGNUM
%token <bool> LET YIELD_BANG LET_BANG 
%token <bool> LESS GREATER /* here the bool indicates if the tokens are part of a type application or type parameter declaration, e.g. C<int>, detected by the lex filter */
%token <string> PERCENT_OP BINDER 
%token <string * bool> LQUOTE RQUOTE  RQUOTE_DOT 
%token BAR_BAR UPCAST DOWNCAST NULL RESERVED MODULE NAMESPACE DELEGATE CONSTRAINT BASE 
%token AND AS ASSERT OASSERT ASR BEGIN DO DONE DOWNTO ELSE ELIF END DOT_DOT
%token EXCEPTION FALSE FOR FUN FUNCTION IF IN JOIN_IN FINALLY DO_BANG 
%token LAZY OLAZY  MATCH MUTABLE REFERENCE NEW OF 
%token WORLD_ENTITY MASTER SLAVE CONNECT DISCONNECT VIRTUAL ENTITY
%token IMPORT OPEN OR REC THEN BODY_OPERATOR TO TRUE TRY TYPE VAL INLINE INTERFACE INSTANCE CONST 
%token WHEN WHILE WITH HASH AMP AMP_AMP QUOTE LPAREN RPAREN RPAREN_COMING_SOON RPAREN_IS_HERE STAR COMMA RARROW GREATER_BAR_RBRACK LPAREN_STAR_RPAREN
%token QMARK QMARK_QMARK DOT COLON COLON_COLON COLON_GREATER  COLON_QMARK_GREATER COLON_QMARK COLON_EQUALS SEMICOLON 
%token SEMICOLON_SEMICOLON LARROW EQUALS  LBRACK  LBRACK_BAR  LBRACK_LESS LBRACE
%token LBRACE_LESS BAR_RBRACK GREATER_RBRACE UNDERSCORE
%token BAR RBRACK RBRACE RBRACE_COMING_SOON RBRACE_IS_HERE MINUS DOLLAR
%token GREATER_RBRACK STRUCT SIG 
%token STATIC MEMBER CLASS ABSTRACT OVERRIDE DEFAULT CONSTRUCTOR INHERIT 
%token EXTERN VOID PUBLIC PRIVATE INTERNAL GLOBAL

//Casanova keywords
 %token RULE CREATE WAIT WAIT_UNTIL YIELD SELECT_OPERATOR PARALLEL_OPERATOR INT_SELECT_OPERATOR

/* for parser 'escape hatch' out of expression context without consuming the 'recover' token */
%token TYPE_COMING_SOON TYPE_IS_HERE MODULE_COMING_SOON MODULE_IS_HERE

/* for high-precedence tyapps and apps */
%token HIGH_PRECEDENCE_BRACK_APP   /* inserted for f[x], but not f [x] */
%token HIGH_PRECEDENCE_PAREN_APP   /* inserted for f(x) and f<int>(x), but not f (x) */
%token HIGH_PRECEDENCE_TYAPP /* inserted for x<y>, but not x<y */

/* for offside rule */
%token <bool> OLET OLET_WAIT      /* LexFilter #light converts 'LET' tokens to 'OLET' when starting (CtxtLetDecl(blockLet=true)) */
%token <string> OBINDER /* LexFilter #light converts 'BINDER' tokens to 'OBINDER' when starting (CtxtLetDecl(blockLet=true)) */
%token OWAIT
%token OPARALLEL_OPERATOR
%token OWHEN
%token OYIELD
%token OWHERE
%token OSELECT
%token ODO              /* LexFilter #light converts 'DO' tokens to 'ODO' */
%token ODO_BANG         /* LexFilter #light converts 'DO_BANG' tokens to 'ODO_BANG' */
%token OTHEN            /* LexFilter #light converts 'THEN' tokens to 'OTHEN' */
%token OBODY_OPERATOR
%token OELSE            /* LexFilter #light converts 'ELSE' tokens to 'OELSE' except if immeditely followed by 'if', when they become 'ELIF' */
%token OWITH            /* LexFilter #light converts SOME (but not all) 'WITH' tokens to 'OWITH' */ 
%token OFUNCTION        /* LexFilter #light converts 'FUNCTION' tokens to 'OFUNCTION' */ 
%token OFUN             /* LexFilter #light converts 'FUN' tokens to 'OFUN' */


%token ORESET           /* LexFilter uses internally to force a complete reset on a ';;' */

%token OBLOCKBEGIN      /* LexFilter #light inserts for:
                                  - just after first '=' or ':' when in 'CtxtModuleHead', i.e. after 'module' and sequence of dot/identifier/access tokens
                                  - just after first '=' when in 'CtxtMemberHead'
                                  - just after first '=' when in 'CtxtType' 
                                  - just after 'do' in any context (when opening CtxtDo)
                                  - just after 'finally' in any context 
                                  - just after 'with' (when opening CtxtWithAsAugment)
                                  - just after 'else' (when opening CtxtElse)
                                  - just after 'then' (when opening CtxtThen)
                                  - just after 'interface' (when pushing CtxtParen(INTERFACE), i.e. next token is DEFAULT | OVERRIDE | INTERFACE | NEW | TYPE | STATIC | END | MEMBER | ABSTRACT  | INHERIT | LBRACK_LESS)
                                  - just after 'class' (when pushing CtxtParen(CLASS)
                                  - just after 'class' 
                           But not when opening these CtxtSeqBlocks:
                                  - just after first non-dot/identifier token past 'namespace' 
                                  - just after first '=' when in 'CtxtLetDecl' or 'CtxtWithAsLet' 
                                  - just after 'lazy' in any context
                                  - just after '->' in any context                                  
                                  - when opening CtxtNamespaceHead, CtxtModuleHead 
                        */
%token OBLOCKSEP        /* LexFilter #light inserts when transforming CtxtSeqBlock(NotFirstInSeqBlock,_,AddBlockEnd) to CtxtSeqBlock(FirstInSeqBlock,_,AddBlockEnd) on exact alignment */

/*    REVIEW: merge OEND, ODECLEND, OBLOCKEND and ORIGHT_BLOCK_END into one token */
%token OEND             /* LexFilter #light inserts when closing CtxtFun, CtxtMatchClauses, CtxtWithAsLet _        */
%token ODECLEND         /* LexFilter #light inserts when closing CtxtDo and CtxtLetDecl(block) */
%token ORIGHT_BLOCK_END /* LexFilter #light inserts when closing CtxtSeqBlock(_,_,AddOneSidedBlockEnd) */
%token OBLOCKEND OBLOCKEND_COMING_SOON OBLOCKEND_IS_HERE       /* LexFilter #light inserts when closing CtxtSeqBlock(_,_,AddBlockEnd) */

%token OINTERFACE_MEMBER /* inserted for non-paranthetical use of 'INTERFACE', i.e. not INTERFACE/END */
%token <token> ODUMMY

/* These are artificial */
%token <string> LEX_FAILURE
%token <LexerWhitespaceContinuation> COMMENT WHITESPACE HASH_LINE HASH_LIGHT INACTIVECODE LINE_COMMENT STRING_TEXT EOF
%token <Position * string * LexerWhitespaceContinuation> HASH_IF HASH_ELSE HASH_ENDIF 
 
 
// start   
%start start   
%type <Program> start   
 
%type <Ident> ident
%type <SynType> typ
%type <SynExpr> patternResult
%type <SynExpr> declExpr
%type <SynExpr> minusExpr
%type <SynExpr> appExpr
%type <SynExpr> argExpr
%type <SynExpr> declExprBlock
%type <SynPat> headBindingPattern
%type <SynExpr> atomicExprAfterType
%type <SynExpr> typedSeqExprBlock
%type <SynExpr * bool> atomicExpr
%type <SynTypeDefnSimpleRepr> tyconDefnOrSpfnSimpleRepr
%type <SynMemberDefns> tyconDefnAugmentation
%type <SynModuleDecl list> moduleDefnsOrExprPossiblyEmptyOrBlock
%type <LongIdentWithDots> path
%type <LongIdentWithDots> pathOp
/*     LESS    GREATER        parsedOk   typeArgs           m for each   mWhole  */
%type <Position * Position option * bool     * SynType list * Position list * Position> typeArgsActual
/*     LESS    GREATER        typeArgs           m for each   mWhole  */
%type <Position * Position option * SynType list * Position list * Position> typeArgsNoHpaDeprecated
%type <SynTypar> typar


%nonassoc prec_args_error             /* less than RPAREN */
%nonassoc prec_atomexpr_lparen_error  /* less than RPAREN */

%right AS

/* prec_wheretyp_prefix = "where typ" lower than extensions, i.e. "WHEN" */
%nonassoc prec_wheretyp_prefix        /* lower than WHEN and RPAREN */
%nonassoc RPAREN RPAREN_COMING_SOON RPAREN_IS_HERE

%right WHEN

/* prec_pat_pat_action = "pattern when expr -> expr"
 * Lower than match extensions - i.e. BAR.
 */
%nonassoc prec_pat_pat_action          /* lower than BAR */

/* "a then b" as an object constructor is very low precedence */
/* Lower than "if a then b" */
%left prec_then_before
%nonassoc prec_then_if 
%left  BAR

%right SEMICOLON  prec_semiexpr_sep OBLOCKSEP
%right prec_defn_sep

/* prec_atompat_pathop = precedence of at atomic pattern, e.g "Constructor".
 * Lower than possible pattern extensions, so "pathOp . extension" does shift not reduce.
 * possible extensions are:
 *  - constant terminals.
 *  - null
 *  - LBRACK = [
 *  - TRUE,FALSE
 */
%nonassoc prec_atompat_pathop
%nonassoc INT8 UINT8 INT16 UINT16 INT32 UINT32 INT64 UINT64 NATIVEINT UNATIVEINT IEEE32 IEEE64 CHAR KEYWORD_STRING STRING BYTEARRAY BIGNUM DECIMAL
%nonassoc LPAREN LBRACE LBRACK_BAR 
%nonassoc TRUE FALSE UNDERSCORE NULL


/* prec_typ_prefix        lower than "T  -> T  -> T" extensions.
 * prec_tuptyp_prefix     lower than "T * T * T * T" extensions.
 * prec_tuptyptail_prefix lower than "T * T * T * T" extensions.
 * Lower than possible extensions:
 *  - STAR, IDENT, RARROW
 *  - LBRACK = [ - for "base[]" types              
 * Shifts not reduces.
 */
%nonassoc prec_typ_prefix             /* lower than STAR, IDENT, RARROW etc */
%nonassoc prec_tuptyp_prefix          /* ditto */
%nonassoc prec_tuptyptail_prefix      /* ditto */
%nonassoc prec_toptuptyptail_prefix      /* ditto */
        
%right    RARROW
%nonassoc IDENT LBRACK

/* prec_opt_attributes_none = precedence of no attributes
 * These can prefix LET-moduleDefns.
 * Committing to an opt_attribute (reduce) forces the decision that a following LET is a moduleDefn.
 * At the top-level, it could turn out to be an expr, so prefer to shift and find out...
 */
%nonassoc prec_opt_attributes_none    /* lower than LET,NEW */

/* LET,NEW higher than SEMICOLON so shift
 *   "seqExpr = seqExpr; . let x = y in z"
 *   "seqExpr = seqExpr; . new...."
 */
%nonassoc LET NEW LET_BANG

       
/* Redundant dummies: expr_let, expr_function, expr_fun, expr_match */
/* Resolves conflict: expr_try, expr_if */
%nonassoc expr_let
%nonassoc decl_let
%nonassoc expr_function expr_fun expr_match expr_try expr_do
%nonassoc decl_match decl_do
%nonassoc expr_if                     /* lower than ELSE to disambiguate "if _ then if _ then _ else _" */
%nonassoc ELSE   

/* prec_atomtyp_path = precedence of atomType "path"
 * Lower than possible extension "path<T1,T2>" to allow "path . <" shift.
 * Extensions: LESS
 */
%nonassoc prec_atomtyp_path           /* lower than LESS */
%nonassoc prec_atomtyp_get_path       /* lower than LESS */

/* prec_no_more_attr_bindings = precedence of "moreLocalBindings = ."
 * Lower precedence than AND so further bindings are shifted.
 */
%nonassoc prec_no_more_attr_bindings  /* lower than AND */
%nonassoc OPEN
%nonassoc IMPORT

/* prec_interfaces_prefix - lower than extensions, i.e. INTERFACE */
%nonassoc prec_interfaces_prefix      /* lower than INTERFACE */
%nonassoc INTERFACE

%right COLON_EQUALS 
%nonassoc pat_tuple expr_tuple
%nonassoc larrow_expr
%right LARROW 
%left COMMA
%nonassoc slice_comma  /* for matrix.[1..2,3..4] the ".." has higher precedence than "2,3" */
%nonassoc DOT_DOT /* for matrix.[1..2,3..4] the ".." has higher precedence than "2,3" */
%nonassoc paren_pat_colon
%nonassoc paren_pat_attribs
%left OR BAR_BAR JOIN_IN
%left AND   /* check */
%left  AMP AMP_AMP 
%nonassoc pat_conj
%nonassoc expr_not
%left COLON_GREATER  COLON_QMARK_GREATER
%left INFIX_COMPARE_OP DOLLAR LESS GREATER EQUALS  INFIX_BAR_OP INFIX_AMP_OP 
%right INFIX_AT_HAT_OP
%right COLON_COLON
%nonassoc pat_isinst 
%left COLON_QMARK
%left PLUS_MINUS_OP MINUS expr_prefix_plus_minus ADJACENT_PREFIX_OP
%left  INFIX_STAR_DIV_MOD_OP STAR PERCENT_OP
%right INFIX_STAR_STAR_OP
%left  QMARK_QMARK
%left head_expr_adjacent_minus
%left expr_app expr_assert expr_lazy LAZY ASSERT
%left arg_expr_adjacent_minus
%left expr_args
%right matching_bar
%left pat_app
%left pat_args
%left PREFIX_OP
%left DOT QMARK
%left HIGH_PRECEDENCE_BRACK_APP
%left HIGH_PRECEDENCE_PAREN_APP
%left HIGH_PRECEDENCE_TYAPP

%nonassoc prec_interaction_empty

%%
 
 
start:  casanovaModuleImpl                  { $1 }   


stringOrKeywordString:
  | STRING { $1 }
  | KEYWORD_STRING { $1 }
      
/* CasanovaCompiler Language Proper */

cnvModuleIntro:
  | module_keyword path { $2 }

casanovaModuleImpl:
  | cnvModuleIntro EOF
    { let m = rhs parseState 1
      {ModuleStatement = $1; WorldOrEntityDecls = []; Range = m; ReferencedLibraries = Seq.empty} }

  | moduleDefnsOrExprPossiblyEmptyOrBlock EOF
    { let m = rhs parseState 1
      {ModuleStatement = LongIdentWithDots([Ident("internal_module", Position.Empty)], []); 
       WorldOrEntityDecls = $1; 
       Range = m;
       ReferencedLibraries = Seq.empty} }


  | cnvModuleIntro moduleDefnsOrExprPossiblyEmptyOrBlock EOF
    { let m2 = rhs parseState 1
      let m = (m2, $2) ||> unionRangeWithListBy (fun modu -> modu.Range) 
      {ModuleStatement = $1; WorldOrEntityDecls = $2; Range = m; ReferencedLibraries = Seq.empty} }

  | cnvModuleIntro moduleDefnsOrExprPossiblyEmptyOrBlock error EOF
    { let m2 = rhs parseState 1
      let m = (m2, $2) ||> unionRangeWithListBy (fun modu -> modu.Range) 
      {ModuleStatement = $1; WorldOrEntityDecls = $2; Range = m; ReferencedLibraries = Seq.empty} }

  | cnvModuleIntro moduleDefnsOrExprPossiblyEmptyOrBlock error EOF
    { let m2 = rhs parseState 1
      let m = (m2, $2) ||> unionRangeWithListBy (fun modu -> modu.Range) 
      {ModuleStatement = $1; WorldOrEntityDecls = $2; Range = m; ReferencedLibraries = Seq.empty} } 

  | recover
    { errorR(Error(FSComp.SR.buildMultiFileRequiresNamespaceOrModule(),rhs parseState 1))
      Program.Empty() }
  /* If this rule fires it is kind of catastrophic: error recovery yields no results! */
  /* This will result in NO intellisense for the file! Ideally we wouldn't need this rule */
  /* Note: the compiler assumes there is at least one "fragment", so an empty one is used (see 4488) */
  | error EOF 
     { errorR(Error(FSComp.SR.buildMultiFileRequiresNamespaceOrModule(),rhs parseState 1))
       Program.Empty() }


moduleDefnsOrExprPossiblyEmptyOrBlock:
  | OBLOCKBEGIN moduleDefnsOrExprPossiblyEmpty oblockend opt_OBLOCKSEP
     { $2 }
  | OBLOCKBEGIN moduleDefnsOrExprPossiblyEmpty recover 
       { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
         // reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight());   
         $2 
       }
  | OBLOCKBEGIN error oblockend                
       { 
         [] 
       }
  | moduleDefnsOrExprPossiblyEmpty
     { $1 }

moduleDefnsOrExprPossiblyEmpty:
  | moduleDefnsOrExpr
     { $1 }
  | 
     { [] }

/* A naked expression is only allowed at the start of a module/file, or straight after a topSeparators */
moduleDefnsOrExpr:
  | moduleDefns 
      { $1 } 

moduleDefns:
  | moduleDefnOrDirective moduleDefns 
      { $1 @ $2 } 
  | moduleDefnOrDirective topSeparators moduleDefnsOrExpr 
      {  $1 @ $3 } 
  | error moduleDefns 
      { $2 } 

  | moduleDefnOrDirective
      { $1 }
  | moduleDefnOrDirective topSeparators
      { $1 }
  | error topSeparators moduleDefnsOrExpr 
      { $3 } 
  
moduleDefnOrDirective:
  | moduleDefn 
      { $1  }
opt_attributes:
  | attributes                                { $1 }
  |            %prec prec_opt_attributes_none { [] }
attributes: 
  | attributeList                     
     { $1 }
  | attributeList attributes
     { $1 @ $2 }

attributeList: 
  | LBRACK_LESS  attributeListElements opt_seps GREATER_RBRACK opt_OBLOCKSEP {  $2 }
  | LBRACK_LESS  error GREATER_RBRACK opt_OBLOCKSEP {  [] }
  | LBRACK_LESS  attributeListElements opt_seps ends_coming_soon_or_recover 
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedLBrackLess());
        $2 }
  | LBRACK_LESS  ends_coming_soon_or_recover 
      { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedLBrackLess());
        [] }

attributeListElements: 
  | attribute                     
     { [$1] }
  | attributeListElements seps attribute 
     { $1 @ [$3] }

attribute:
  | path opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $3 with None -> mkSynUnit $1.Range | Some e -> e 
       ({ TypeName=$1; ArgExpr=arg; Target=None; AppliesToGetterAndSetter=false; Range=$1.Range } : SynAttribute) }
  | attributeTarget path opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $4 with None -> mkSynUnit $2.Range | Some e -> e 
       ({ TypeName=$2; ArgExpr=arg; Target=$1; AppliesToGetterAndSetter=false; Range=$2.Range } : SynAttribute) }
  | attributeTarget OBLOCKBEGIN path oblockend opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType 
     { let arg = match $6 with None -> mkSynUnit $3.Range | Some e -> e 
       ({ TypeName=$3; ArgExpr=arg; Target=$1; AppliesToGetterAndSetter=false; Range=$3.Range } : SynAttribute) }

attributeTarget: 
  | module_keyword COLON { Some(ident("module",(rhs parseState 1))) } 
  | type_keyword COLON { Some(ident("type",(rhs parseState 1))) } 
  | ident COLON { Some($1) } 


/* This is used by both "fsi" interactions and "source file" fragments defined by moduleDefns */
moduleDefn:

  | opt_attributes hardwhiteLetBindings          %prec decl_let 
      { let hwlb,m = $2
        mkEntryPoint (m,hwlb,$1,m)  }

  | opt_attributes doBinding %prec decl_let 
    { printfn "Hello!"
      let mWhole = rhs parseState 3 
      mkEntryPoint (mWhole,$2,$1,mWhole) }
  | WORLD_ENTITY tyconDefn tyconDefnList
      { let types = ($2, true) :: $3
        [ SynModuleDecl.Types(types, (rhs parseState 1, (types |> List.map(fun e -> fst e))) ||> unionRangeWithListBy (fun t -> t.Range) ) ] }
  | type_keyword tyconDefn tyconDefnList
      { let types = ($2, $1) :: $3
        [ SynModuleDecl.Types(types, (rhs parseState 1, (types |> List.map(fun e -> fst e))) ||> unionRangeWithListBy (fun t -> t.Range) ) ] }
    
  

  | OPEN path 
      { [SynModuleDecl.Open($2, $2.Range)] }
  
  | importLibrary
      { let elem, elem_range = $1
        [SynModuleDecl.OpenLibrary(elem, elem_range)] }

  | importDecl 
      { let elem, elem_range = $1
        [SynModuleDecl.Import(elem, elem_range)] }

/* this occurs on the right of a module abbreviation (#light encloses the r.h.s. with OBLOCKBEGIN/OBLOCKEND) */
/* We don't use it in signature files */
namedModuleAbbrevBlock:
  | OBLOCKBEGIN path oblockend 
       { $2.Lid }
  | path 
       { $1.Lid  }
       
namedModuleDefnBlock:
  | OBLOCKBEGIN wrappedNamedModuleDefn oblockend 
       { 
         Choice2Of2 $2 
       }
  | OBLOCKBEGIN wrappedNamedModuleDefn recover
       { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
         Choice2Of2 $2 
       }
  | OBLOCKBEGIN moduleDefnsOrExpr recover 
       { // The lex filter ensures we can only get a mismatch in OBLOCKBEGIN/OBLOCKEND tokens if there was some other kind of error, hence we don't need to report this error
         // reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnClosedBlockInHashLight());   
         Choice2Of2 $2 
       }
  | OBLOCKBEGIN error oblockend                
       { 
         Choice2Of2 [] 
       }
  | wrappedNamedModuleDefn 
       {
         Choice2Of2 $1 
        }
  | path 
        {
         Choice1Of2 $1.Lid
        }

wrappedNamedModuleDefn:
  | structOrBegin moduleDefnsOrExprPossiblyEmpty END 
       { $2 }
  | structOrBegin moduleDefnsOrExprPossiblyEmpty recover 
       { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBeginOrStruct());  
         $2 }
  | structOrBegin error END                      
       { [] }

opt_signature :
  | 
       { None }

tyconDefnAugmentation: 
  | WITH classDefnBlock declEnd
     { $2 }

opt_literalValue: 
  | { None }
  | EQUALS declExpr { Some($2) }
  | EQUALS OBLOCKBEGIN declExpr oblockend { Some($3) }

memberFlags: 
  | MEMBER          { (false,NonVirtualMemberFlags) }
  | RULE			{ (false,NonVirtualMemberFlags) }
  | CREATE       { (false,NonVirtualMemberFlags) }

memberSpecFlags: 
  | memberFlags { $1 }  
  | ABSTRACT        { (false,AbstractMemberFlags) }
  | ABSTRACT MEMBER { (false,AbstractMemberFlags) }

classMemberSpfnGetSet:
  | /* EMPTY */ 
    { None, MemberKind.Member }
  | WITH classMemberSpfnGetSetElements 
    { Some (rhs2 parseState 1 2), $2 }
  | OWITH classMemberSpfnGetSetElements OEND
    { Some (rhs2 parseState 1 2), $2 }
  | OWITH classMemberSpfnGetSetElements error
    {  reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedWith());
       Some (rhs2 parseState 1 2), $2 }


classMemberSpfnGetSetElements:
  | nameop 
    { (let (id:Ident) = $1 
       if id.idText = "get" then MemberKind.PropertyGet 
       else if id.idText = "set" then MemberKind.PropertySet 
       else raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsGetOrSetRequired())) }
  | nameop COMMA nameop
    { let (id:Ident) = $1 
      if not ((id.idText = "get" && $3.idText = "set") ||
              (id.idText = "set" && $3.idText = "get")) then 
         raiseParseErrorAt (rhs2 parseState 1 3) (FSComp.SR.parsGetOrSetRequired());
      MemberKind.PropertyGetSet }

typeNameInfo: 
  | tyconNameAndTyparDecls
     { $1 }

tyconDefnList:  
  | AND tyconDefn tyconDefnList 
     { ($2, false) :: $3 } 
  |                             
     { [] }

tyconDefn:
  | typeNameInfo EQUALS tyconDefnRhsBlock
     { let nameRange = rhs parseState 1
       let (tcDefRepr:SynTypeDefnRepr),members, inherits = $3 nameRange
       let declRange = unionRanges (rhs parseState 1) tcDefRepr.Range
       let mWhole = (declRange, members) ||> unionRangeWithListBy (fun (mem:SynMemberDefn) -> mem.Range)    
       TypeDefn($1, tcDefRepr, members, inherits, mWhole) }

tyconDefnRhsBlock: 
  /* This rule allows members to be given for record and union types in the #light syntax */
  /* without the use of 'with' ... 'end'. For example: */
  /*     type R = */
  /*         { a : int } */
  /*         member r.A = a */
  /* It also takes into account that any existing 'with' */
  /* block still needs to be considered and may occur indented or undented from the core type */
  /* representation. */
  | OBLOCKBEGIN  cnvTyconDefnRhs opt_OBLOCKSEP opt_classDefn oblockend opt_classDefn 
     { let m = unionRanges (rhs parseState 1) (match $6 with [] -> (match $4 with [] -> (rhs parseState 3) | _ -> (rhs parseState 4)) | _ -> (rhs parseState 6))
       let fields,rules = $2
       (fun nameRange -> fields nameRange (checkForMultipleAugmentations m (rules @ $4) $6)) }
	     

  | OBLOCKBEGIN  tyconDefnRhs opt_OBLOCKSEP opt_classDefn oblockend opt_classDefn  
     { let m = unionRanges (rhs parseState 1) (match $6 with [] -> (match $4 with [] -> (rhs parseState 3) | _ -> (rhs parseState 4)) | _ -> (rhs parseState 6))
       (fun nameRange -> $2 nameRange (checkForMultipleAugmentations m $4 $6)) }
/*  | OBLOCKBEGIN  tyconDefnRhs opt_OBLOCKSEP classDefnMembers opt_classDefn recover
     { if not $6 then reportParseErrorAt (rhs parseState 6) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition())
       let m = unionRanges (rhs parseState 1) (match $5 with [] -> (rhs parseState 4) | _ -> (rhs parseState 5))
       (fun nameRange -> $2 nameRange (checkForMultipleAugmentations m ($4 @ $5) [])) }
  | tyconDefnRhs opt_classDefn
     { let m = rhs parseState 1
       (fun nameRange -> $1 nameRange $2) }
  */
cnvTyconDefnRhs:
  | tyconDefnOrSpfnCnvRepr
     {  
       let inherits,m,rules = $1
       (fun nameRange augmentation -> SynTypeDefnRepr.Simple (m,m.Range),augmentation, inherits),rules }

tyconDefnRhs:
  | tyconDefnOrSpfnSimpleRepr 
     { let m = $1.Range
       (fun nameRange augmentation -> SynTypeDefnRepr.Simple ($1,m),augmentation, [])}


classDefnBlock:
  | OBLOCKBEGIN  classDefnMembers recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition());
        $2 }
  | OBLOCKBEGIN  classDefnMembers oblockend
      { $2 }
  | classDefnMembers 
      { $1 }

/*
classDefnBlockAtLeastOne:
  | OBLOCKBEGIN  classDefnMembersAtLeastOne recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeDefinition());
        $2 }
  | OBLOCKBEGIN  classDefnMembersAtLeastOne oblockend 
      { $2 }
  | classDefnMembersAtLeastOne 
      { $1 }
*/

classDefnMembers:  
  | classDefnMembersAtLeastOne
     { $1 }
  /* REVIEW: Error recovery rules that are followed by potentially empty productions are suspicious! */
  | error classDefnMembers 
     { $2 }
  | 
     { [] }
  
classDefnMembersAtLeastOne:  
  | classDefnMember opt_seps classDefnMembers 
     { $1 @  $3 }

memberCore:  
 /* methods and simple getter properties */
  | opt_inline bindingPattern  opt_topReturnTypeWithTypeConstraints EQUALS typedSeqExprBlock  
     {  
        
        let mRhs = $5.Range 
        let mWhole = unionRanges (rhs2 parseState 3 4) mRhs 
        let optReturnType = $3 
        let bindingBuilder,mBindLhs = $2 
        let opt = 
            match $1 with
            | 1 -> Flag.Master
            | 2 -> Flag.Slave
            | 3 -> Flag.Connect
            | _ -> Flag.Nothing

        (fun vis memFlagsBuilder -> 

             let b = bindingBuilder (mBindLhs,optReturnType,$5,Some(memFlagsBuilder MemberKind.Member))
             [ SynMemberDefn.Member (b,unionRanges mWhole mBindLhs, opt) ]) }

createMemberCoreWithParams:  
  | opt_inline createBindingPattern  opt_topReturnTypeWithTypeConstraints EQUALS typedSeqExprBlock  
     {  
        
        let mRhs = $5.Range 
        let mWhole = unionRanges (rhs2 parseState 3 4) mRhs 
        let optReturnType = $3 
        let bindingBuilder,mBindLhs = $2 
        (fun vis memFlagsBuilder -> 
             let b = bindingBuilder (mBindLhs,optReturnType,$5,Some(memFlagsBuilder MemberKind.Member))             
             [ SynMemberDefn.Member(make_synexpr_create b,unionRanges mWhole mBindLhs, Nothing) ]) }


createMemberCore:  
 /* methods and simple getter properties */
  | opt_inline opt_topReturnTypeWithTypeConstraints EQUALS typedSeqExprBlock  
     {  
        
        let mRhs = $4.Range 
        let mWhole = unionRanges (rhs2 parseState 2 3) mRhs 
        let optReturnType = $2 
        (fun vis memFlagsBuilder _range -> 
             let test = mkSynPatMaybeVar (LongIdentWithDots([Ident("Create",_range)],[])) _range
             [ SynMemberDefn.Member (mkSynBinding test (_range,optReturnType,$4,Some(memFlagsBuilder MemberKind.Member)),unionRanges mWhole _range, Nothing) ]) }

abstractMemberFlags: 
  | ABSTRACT {} 
  | ABSTRACT MEMBER {} 

classDefnMember:              
  | opt_declVisibility memberFlags memberCore  opt_ODECLEND
     { if isSome $1 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(),rhs parseState 1));
       let _,flags = $2
       $3 $1 flags}


opt_typ:
   | /* EMPTY */ { None } 
   | COLON typ { Some $2 }

   
atomicPatternLongIdent:
  | GLOBAL DOT pathOp  
    {   let (LongIdentWithDots(lid,dotms)) = $3 
        (None,LongIdentWithDots(ident(MangledGlobalName,rhs parseState 1)::lid, rhs parseState 2::dotms)) }
  | pathOp { (None,$1) }

/* only valid on 'NEW' */
opt_declVisibility:
  |  { None }

opt_classDefn: 
  | WITH classDefnBlock declEnd { $2 } 
  |                           { [] }

optAsSpec: 
  | asSpec { Some($1) } 
  |        { None }

asSpec: 
  | AS ident { $2 } 

optBaseSpec: 
  | baseSpec { Some($1) } 
  |        { None }

baseSpec: 
  | AS ident 
      { if ($2).idText <> "base" then 
             errorR(Error(FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings(),rhs2 parseState 1 2)); 
        ident("base",rhs parseState 2) } 
        
  | AS BASE 
      { errorR(Error(FSComp.SR.parsInheritDeclarationsCannotHaveAsBindings(),rhs2 parseState 1 2)); 
        ident("base",rhs parseState 2) } 

memberOrOverride: 
  | MEMBER {   } 
  | OVERRIDE {   }


tyconDefnOrSpfnSimpleRepr: 
  | opt_declVisibility unionRepr
     { let _SynUnionCases : Choice<_,SynUnionCase> list = $2
       let rangesOf3 = _SynUnionCases |> List.map (function |Choice1Of2(ec)->ec.Range | Choice2Of2(uc)->uc.Range)
       let mWhole = (rhs parseState 1, rangesOf3) ||> List.fold unionRanges 
       SynTypeDefnSimpleRepr.Union ( _SynUnionCases |> List.choose (function Choice2Of2 data -> Some(data) | Choice1Of2 _ -> failwith "huh?"),
                                     mWhole) }

tyconDefnOrSpfnCnvRepr:
  | opt_declVisibility braceFieldOrRuleDeclList
     { let inherits,fields,rules = $2
       inherits,(SynTypeDefnSimpleRepr.Record (fields,lhs parseState)),rules }

braceFieldOrRuleDeclList:
  | LBRACE  fieldOrRuleList rbrace
     { let fieldsOrInherit,rules = split (fun x -> match x with CnvRule (_) -> false |_ -> true ) $2
       let inherits, fields = split (fun x -> match x with CnvField (_) -> false |_ -> true ) fieldsOrInherit
       let fields,rules = fields |> List.map(fun x -> x.GetField),rules |> List.map(fun x -> x.GetRule)
       let inherits = inherits |> List.map(fun x -> x.GetInherit)
       if (inherits.Length > 1) then failwith "Multiple inherits keywords definition per entity not allowed."
       if inherits.Length = 1 then inherits.Head, fields,rules
       else [], fields,rules}
  | LBRACE  fieldOrRuleList recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace()); 
       let fieldsOrInherit,rules = split (fun x -> match x with CnvRule (_) -> false |_ -> true ) $2
       let inherits, fields = split (fun x -> match x with CnvField (_) -> false |_ -> true ) fieldsOrInherit
       let fields,rules = fields |> List.map(fun x -> x.GetField),rules |> List.map(fun x -> x.GetRule)
       let inherits = inherits |> List.map(fun x -> x.GetInherit)
       if (inherits.Length > 1) then failwith "Multiple inherits keywords definition per entity not allowed."
       if inherits.Length = 1 then inherits.Head, fields,rules
       else [], fields,rules}
  /* | LBRACE  error rbrace */
  /*   { [] } */

fieldOrRuleList: /* AST: FieldOrRule list */
  | fieldOrRule { [$1] }
  | fieldOrRule opt_OBLOCKSEP fieldOrRuleList { $1 :: $3 }

topReturnTypeWithTypeConstraints:
  | COLON topTypeWithTypeConstraints 
     { let ty,arity = $2 
       let arity = (match arity with SynValInfo([],rmdata)-> rmdata | _ -> SynInfo.unnamedRetVal)
       Some (SynReturnInfo((ty,arity),rhs parseState 2)) }

cnvFieldInitCore:
   /* methods and simple getter properties */
  |  bindingPattern topReturnTypeWithTypeConstraints EQUALS typedSeqExprBlock  
     {  let mRhs = $4.Range 
        let mWhole = unionRanges (rhs2 parseState 2 3) mRhs 
        let optReturnType = $2 
        let bindingBuilder,mBindLhs = $1 
        (fun vis memFlagsBuilder -> 
             [ SynMemberDefn.Member (bindingBuilder (mBindLhs,optReturnType,$4,Some(memFlagsBuilder MemberKind.Member)),unionRanges mWhole mBindLhs, Nothing) ]) }

fieldOrRule: 

/* SynM4emberDefn.Member */
  | opt_declVisibility RULE memberCore  opt_ODECLEND
     { if isSome $1 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(),rhs parseState 1));
       let flags = NonVirtualMemberFlags
       let res = $3 $1 flags
       CnvRule (res.Head) }

  | opt_declVisibility CREATE createMemberCoreWithParams  opt_ODECLEND
     { if isSome $1 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(),rhs parseState 1));
       let flags = NonVirtualMemberFlags
       let res = $3 $1 flags
       CnvRule (res.Head) } 


  | opt_declVisibility CREATE createMemberCore  opt_ODECLEND
     { if isSome $1 then errorR(Error(FSComp.SR.parsVisibilityDeclarationsShouldComePriorToIdentifier(),rhs parseState 1));
       let flags = StaticMemberFlags
       let res = $3 $1 flags (rhs parseState 2)
       CnvRule (res.Head) }  
  
  | OLET opt_declVisibility cnvFieldInitCore opt_ODECLEND
     { let flags = NonVirtualMemberFlags
       let res = $3 $2 flags
       let res_head = res.Head
       CnvRule (res_head) }
  | INHERIT inherit_idents
    { CnvInherit $2 }
  | fieldDecl
     { let (Field(c,d,is_ref,g)) = $1 
       CnvField (Field(c,d,is_ref,g))  }

inherit_idents:
  | IDENT { [Ident($1, lhs parseState)] }
  | IDENT COMMA inherit_idents { Ident($1, lhs parseState) :: $3 }

braceFieldDeclList:
  | LBRACE  recdFieldDeclList rbrace
     { $2 }
  | LBRACE  recdFieldDeclList recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace()); 
       $2 }
  | LBRACE  error rbrace
     { [] }

interfaceMember: 
  | INTERFACE { } 
  | OINTERFACE_MEMBER    { }

tyconNameAndTyparDecls:  
  | path 
      { $1.Lid }

typarAlts:
	| typarAlts OR typar { $3::$1 }
	| typar { [$1] }	

unionRepr:
  /* Note the next three rules are required to disambiguate this from type x = y */
  /* Attributes can only appear on a single constructor if you've used a | */
  | attrUnionCaseDecls  
     { $1 }
  | firstUnionCaseDeclOfMany attrUnionCaseDecls  
     { $1 :: $2}
  | firstUnionCaseDecl 
     { [$1] } 

attrUnionCaseDecls: 
  | attrUnionCaseDecl attrUnionCaseDecls  { $1 :: $2 } 
  | attrUnionCaseDecl { [ $1 ] }

attrUnionCaseDecl: 
  | unionCaseName opt_OBLOCKSEP
      { let mDecl = rhs parseState 1
        Choice2Of2 (UnionCase ($1,UnionCaseFields [],mDecl)) 
      } 
  | unionCaseName OF unionCaseRepr  opt_OBLOCKSEP
      { let mDecl = rhs2 parseState 1 3
        Choice2Of2 (UnionCase ($1,UnionCaseFields $3,mDecl)) 
      } 
  | unionCaseName COLON topType opt_OBLOCKSEP
      { libraryOnlyWarning(lhs parseState);
        let mDecl = rhs2 parseState 1 3
        Choice2Of2 (UnionCase ($1,UnionCaseFullType $3,mDecl))
      }

/* REVIEW: unify this with operatorName! */
unionCaseName: 
  | nameop  
      { $1 } 
  | LPAREN COLON_COLON rparen  
      {  ident(opNameCons,rhs parseState 2) }  
  | LPAREN LBRACK RBRACK  rparen  
      {  ident(opNameNil,rhs2 parseState 2 3) }  

firstUnionCaseDeclOfMany: 
  | ident opt_OBLOCKSEP
      { 
        Choice2Of2 (UnionCase ($1,UnionCaseFields [],rhs parseState 1)) 
      } 
  | firstUnionCaseDecl opt_OBLOCKSEP
      { $1 }

firstUnionCaseDecl: 
  | ident OF unionCaseRepr  
     { 
       Choice2Of2 (UnionCase ($1,UnionCaseFields $3,rhs2 parseState 1 3))
    }

unionCaseRepr:
  | braceFieldDeclList
     { errorR(Deprecated(FSComp.SR.parsConsiderUsingSeparateRecordType(),lhs parseState)); 
       $1 }
  | appType STAR tupleTypeElements 
     { List.map mkAnonField ($1 :: $3) }
  | appType 
     { [mkAnonField $1] }

recdFieldDeclList: 
  | recdFieldDecl seps recdFieldDeclList 
     { $1 :: $3 } 
  | recdFieldDecl opt_seps           
     { [$1] }

recdFieldDecl: 
  | fieldDecl
     { let fld = $1
       let (Field(c,d,is_ref,g)) = fld
       Field(c,d,is_ref,g)  }

fieldDecl: 
  | opt_ref ident COLON  typ 
     { let mRhs = rhs2 parseState 1 4
       Field(Some $2,$4,$1,mRhs) }


importDecl:  
  |  IMPORT STRING { ($2, lhs parseState) }

importLibrary:  
  |  OPEN STRING { ($2, lhs parseState) }

defnBindings: 
  | LET opt_rec localBindings 
      { let mLetKwd = rhs parseState 1 
        let isUse = $1
        let isRec = $2 
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise Position of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs2 parseState 1 2 (* there was some error - this will be an approximate Position *)
            | Some lastRange -> unionRanges mLetKwd lastRange

        let binds = localBindingsBuilder 
        if not isRec && List.length binds > 1 then  
            reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings()); 
        // The first binding swallows any attributes prior to the 'let'
        BindingSetPreAttrs( mLetKwd,isRec,isUse,
                            binds, 
                            bindingSetRange, false) }
defnBindingsWait: 
  | LET_BANG opt_rec localBindings 
      { let mLetKwd = rhs parseState 1 
        printf "babababa "
        let isUse = $1
        let isRec = $2 
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise Position of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs2 parseState 1 2 (* there was some error - this will be an approximate Position *)
            | Some lastRange -> unionRanges mLetKwd lastRange

        let binds = localBindingsBuilder 
        if not isRec && List.length binds > 1 then 
            reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings()); 
        // The first binding swallows any attributes prior to the 'let'
        BindingSetPreAttrs( mLetKwd,isRec,isUse,
                            binds, 
                            bindingSetRange, true) }

doBinding:

  | DO typedSeqExprBlock 
      { let mDoKwd = rhs parseState 1 
        let mWhole = unionRanges mDoKwd $2.Range
        // any attributes prior to the 'let' are left free, e.g. become top-level attributes 
        // associated with the module, 'main' function or assembly depending on their target 
        BindingSetPreAttrs(mDoKwd,false,false,[mkSynDoBinding (true,$2,mWhole)], mWhole, false) }

hardwhiteLetWaitBindings: 
  | OLET_WAIT opt_rec localBindings hardwhiteDefnBindingsTerminator
      { let mLetKwd = rhs parseState 1 
        let isUse = $1
        let isRec = $2
        $4 (if isUse then "use" else "let") mLetKwd;  // report unterminated error 
        
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise Position of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs parseState 1 (* there was some error - this will be an approximate Position *)
            | Some lastRange -> unionRanges mLetKwd lastRange
        
        let binds = localBindingsBuilder 
        if not isRec && List.length binds > 1 then 
            reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings()); 
        
        // the first binding swallow any attributes prior to the 'let' 
        BindingSetPreAttrs(mLetKwd,isRec,isUse,binds,bindingSetRange,true), (unionRanges mLetKwd bindingSetRange) }

hardwhiteLetBindings: 
  | OLET opt_rec localBindings hardwhiteDefnBindingsTerminator
      { let mLetKwd = rhs parseState 1 
        let isUse = $1
        let isRec = $2
        $4 (if isUse then "use" else "let") mLetKwd;  // report unterminated error 
        
        let localBindingsLastRangeOpt, localBindingsBuilder = $3
        
        // Calculate the precise Position of the binding set, up to the end of the last r.h.s. expression
        let bindingSetRange = 
            match localBindingsLastRangeOpt with 
            | None -> rhs parseState 1 (* there was some error - this will be an approximate Position *)
            | Some lastRange -> unionRanges mLetKwd lastRange
        
        let binds = localBindingsBuilder 
        if not isRec && List.length binds > 1 then 
            reportParseErrorAt mLetKwd (FSComp.SR.parsLetAndForNonRecBindings()); 
        
        // the first binding swallow any attributes prior to the 'let' 
        BindingSetPreAttrs(mLetKwd,isRec,isUse,binds,bindingSetRange,false), (unionRanges mLetKwd bindingSetRange) }

hardwhiteDoBinding:

  | ODO typedSeqExprBlock hardwhiteDefnBindingsTerminator          
      { let mLetKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mLetKwd $2.Range 
        let seqPt = NoSequencePointAtDoBinding 
        // any attributes prior to the 'let' are left free, e.g. become top-level attributes 
        // associated with the module, 'main' function or assembly depending on their target 
        BindingSetPreAttrs(mLetKwd,false,false,[mkSynDoBinding (true,$2,bindingSetRange)],bindingSetRange, false), $2 }

classDefnBindings: 
  | defnBindings { $1 }
  | doBinding { $1 }
  | hardwhiteLetBindings { let b,m = $1 in b } 
  | hardwhiteDoBinding  { fst $1 }


hardwhiteDefnBindingsTerminator:
  |  ODECLEND
     { (fun _ m -> ()) }
  |  recover 
     { (fun kwd m -> reportParseErrorAt m (match kwd with 
                                           | "let!" -> FSComp.SR.parsUnmatchedLetBang() 
                                           | "use!" -> FSComp.SR.parsUnmatchedUseBang() 
                                           | "use" -> FSComp.SR.parsUnmatchedUse() 
                                           | _ (*"let" *) -> FSComp.SR.parsUnmatchedLet()))  }

localBindings: 
  | attr_localBinding moreLocalBindings 
      { let (moreBindings, moreBindingRanges) = List.unzip $2
        let moreLocalBindingsLastRange = if moreBindingRanges.IsEmpty then None else Some (last moreBindingRanges)
        match $1 with 
        | Some (localBindingRange,attrLocalBindingBuilder) -> 
           let lastRange = 
               match moreLocalBindingsLastRange with 
               | None -> localBindingRange 
               | Some m -> m
           Some lastRange, attrLocalBindingBuilder ::  moreBindings
        | None -> 
           moreLocalBindingsLastRange, moreBindings }

moreLocalBindings: 
  | AND attr_localBinding moreLocalBindings 
      { let mLetKwd = rhs parseState 1
        (match $2 with 
         | Some (localBindingRange,attrLocalBindingBuilder) -> (attrLocalBindingBuilder ,localBindingRange) :: $3 
         | None -> $3) }
  | %prec prec_no_more_attr_bindings 
      { [] }

attr_localBinding: 
  | localBinding 
      { let localBindingRange,localBindingBuilder = $1
        let attrLocalBindingBuilder = localBindingBuilder
        Some(localBindingRange,attrLocalBindingBuilder) }
  | error 
      { None }

localBinding: 
  | opt_inline opt_mutable bindingPattern  opt_topReturnTypeWithTypeConstraints EQUALS  typedExprWithStaticOptimizationsBlock 
      { let (expr:SynExpr),opts = $6
        let mRhs = expr.Range 
        let optReturnType = $4 
        let bindingBuilder, mBindLhs = $3 
        let localBindingRange = unionRanges (rhs2 parseState 3 5) mRhs
        let localBindingBuilder = bindingBuilder (mBindLhs,optReturnType,expr,None)
        localBindingRange,localBindingBuilder }
  | opt_inline opt_mutable bindingPattern opt_topReturnTypeWithTypeConstraints EQUALS  error
      { let mWhole = rhs2 parseState 3 5 
        let optReturnType = $4 
        let bindingBuilder,mBindLhs = $3 
        let localBindingBuilder = 
            let eqm = rhs parseState 5
            let zeroWidthAtEnd = eqm
            bindingBuilder (mBindLhs,optReturnType,arbExpr("localBinding1",zeroWidthAtEnd),None) 
        mWhole,localBindingBuilder }
  | opt_inline opt_mutable bindingPattern  opt_topReturnTypeWithTypeConstraints recover
      { if not $5 then reportParseErrorAt (rhs parseState 5) (FSComp.SR.parsUnexpectedEndOfFileDefinition())
        let optReturnType = $4 
        let mWhole = match optReturnType with None -> rhs parseState 3 | Some _ -> rhs2 parseState 3 4
        let mRhs = mWhole  // zero-width Position at end of last good token
        let bindingBuilder,mBindLhs = $3 
        let localBindingBuilder = bindingBuilder (mBindLhs,optReturnType,arbExpr("localBinding2",mRhs),None)
        mWhole,localBindingBuilder }

/* REVIEW: this should probably be an expression form rather than tied to this particular part of the grammar */
typedExprWithStaticOptimizationsBlock: 
  | OBLOCKBEGIN typedExprWithStaticOptimizations oblockend 
      { $2 }
  | OBLOCKBEGIN typedExprWithStaticOptimizations recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFile());
        let a,b = $2
        (exprFromParseError a, b) }
  | typedExprWithStaticOptimizations 
      { $1 }

typedExprWithStaticOptimizations : 
  | typedSeqExpr opt_staticOptimizations { $1, List.rev $2 }

opt_staticOptimizations: 
  | opt_staticOptimizations staticOptimization { $2 :: $1 } 
  | { [] }

staticOptimization: 
  | WHEN staticOptimizationConditions EQUALS typedSeqExprBlock { ($2,$4) }

staticOptimizationConditions: 
  | staticOptimizationConditions AND staticOptimizationCondition { $3 :: $1 } 
  | staticOptimizationCondition { [$1 ] }

staticOptimizationCondition: 
  | typar COLON typ { CasanovaCompiler.ParseAST.WhenTyparTyconEqualsTycon($1,$3,lhs parseState) }
  | typar STRUCT { CasanovaCompiler.ParseAST.WhenTyparIsStruct($1,lhs parseState) }

rawConstant: 
  | UINT8 { SynConst.Byte $1 } 
  | INT32 { if snd $1 then errorR(Error(FSComp.SR.lexOutsideThirtyTwoBitSigned(), lhs parseState));
            SynConst.Int32 (fst $1) } 
  | IEEE32 { SynConst.Single $1 } 
  | IEEE64 { SynConst.Double $1 } 
  | CHAR { SynConst.Char $1 } 
  | stringOrKeywordString { SynConst.String ($1,lhs parseState) } 

anonLambdaExpr: 
  | FUN atomicPatterns RARROW typedSeqExprBlock 
     { let mAll = unionRanges (rhs parseState 1) $4.Range
       mkSynFunMatchLambdas false mAll $2 $4 }
  | FUN atomicPatterns RARROW error
     { let mAll = rhs2 parseState 1 3
       mkSynFunMatchLambdas false mAll $2 (arbExpr("anonLambdaExpr1",(rhs parseState 4))) }
  | OFUN atomicPatterns RARROW typedSeqExprBlockR OEND
     { let e : SynExpr = $4
       let mAll = unionRanges (rhs parseState 1) e.Range       
       mkSynFunMatchLambdas false mAll $2 e }
  | OFUN atomicPatterns RARROW typedSeqExprBlockR recover
     { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFunBody());
       let e : SynExpr = $4 
       let mAll = unionRanges (rhs parseState 1) e.Range
       exprFromParseError (mkSynFunMatchLambdas false mAll $2 e) }
  | OFUN atomicPatterns RARROW ORIGHT_BLOCK_END OEND
     { reportParseErrorAt (rhs2 parseState 1 3) (FSComp.SR.parsMissingFunctionBody())
       mkSynFunMatchLambdas false (rhs2 parseState 1 3) $2 (arbExpr("anonLambdaExpr2",(rhs parseState 4))) }

  | OFUN atomicPatterns RARROW recover
     { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFunBody())
       exprFromParseError (mkSynFunMatchLambdas false (rhs2 parseState 1 3) $2 (arbExpr("anonLambdaExpr3",(rhs parseState 4)))) }
  | OFUN atomicPatterns error OEND
     { exprFromParseError (mkSynFunMatchLambdas false (rhs2 parseState 1 2) $2 (arbExpr("anonLambdaExpr4",(rhs parseState 3)))) }
  | OFUN error OEND
     { exprFromParseError (mkSynFunMatchLambdas false (rhs parseState 1) [] (arbExpr("anonLambdaExpr5",(rhs parseState 2)))) }

constant: 
  | rawConstant { $1 }
  | rawConstant HIGH_PRECEDENCE_TYAPP measureTypeArg { SynConst.Measure($1, $3) }

bindingPattern:
  | headBindingPattern   
      { mkSynBinding $1, rhs parseState 1 }

createBindingPattern:
  | headBindingPattern   
      { 
        let tuple = $1
        let tuple1 = SynPat.LongIdent(LongIdentWithDots([Ident("Create", rhs parseState 1)],[]),None, [tuple], rhs parseState 1)
        mkCreateSynBinding tuple1, rhs parseState 1 
      }


headBindingPattern:
  | headBindingPattern AS ident 
      { SynPat.Named ($1,$3,false,rhs2 parseState 1 3) }
  | headBindingPattern BAR headBindingPattern  
      { SynPat.Or($1,$3,rhs2 parseState 1 3) }
  | headBindingPattern COLON_COLON  headBindingPattern 
      { SynPat.LongIdent (LongIdentWithDots(mkSynCaseName (rhs parseState 2) opNameCons,[]), None,[SynPat.Tuple ([$1;$3],rhs2 parseState 1 3)],lhs parseState) }
  | tuplePatternElements  %prec pat_tuple 
      { SynPat.Tuple(List.rev $1, lhs parseState) }
  | conjPatternElements   %prec pat_conj
      { SynPat.Ands(List.rev $1, lhs parseState) }
  | constrPattern 
      { $1 }
tuplePatternElements: 
  | tuplePatternElements COMMA headBindingPattern 
      { $3 :: $1 }
  | headBindingPattern COMMA headBindingPattern 
      { $3 :: $1 :: [] }

conjPatternElements: 
  | conjPatternElements AMP headBindingPattern 
      { $3 :: $1 }
  | headBindingPattern AMP headBindingPattern 
      { $3 :: $1 :: [] }

constrPattern:
  | atomicPatternLongIdent opt_explicitValTyparDecls2                     atomicPatterns    %prec pat_app 
      { let vis,lid = $1 in SynPat.LongIdent (lid,None,$3,lhs parseState) }
  | atomicPatternLongIdent opt_explicitValTyparDecls2 HIGH_PRECEDENCE_PAREN_APP atomicPatterns                  
      { let vis,lid = $1 in SynPat.LongIdent (lid,None,$4,lhs parseState) }
  | atomicPatternLongIdent opt_explicitValTyparDecls2 HIGH_PRECEDENCE_BRACK_APP atomicPatterns                  
      { let vis,lid = $1 in SynPat.LongIdent (lid,None,$4,lhs parseState) }
  | atomicPattern 
      { $1 }

opt_explicitValTyparDecls2: { None }

atomicPatterns: 
  | atomicPattern atomicPatterns %prec pat_args 
      { $1 :: $2 } 
  | atomicPattern HIGH_PRECEDENCE_BRACK_APP atomicPatterns 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled());
        $1 :: $3 } 
  | atomicPattern HIGH_PRECEDENCE_PAREN_APP atomicPatterns 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessivePatternsShouldBeSpacedOrTupled());
        $1 :: $3 } 
  | atomicPattern { [$1] }


atomicPattern:
  | LBRACE recordPatternElements rbrace
      { $2 }
  | LBRACK listPatternElements RBRACK
      { SynPat.ArrayOrList(false,$2,lhs parseState) }
  | LBRACK_BAR listPatternElements  BAR_RBRACK
      { SynPat.ArrayOrList(true,$2, lhs parseState) }
  | UNDERSCORE 
      { SynPat.Wild (lhs parseState) }
   | atomicPatternLongIdent %prec prec_atompat_pathop 
      { let vis,lidwd = $1 
        if List.length lidwd.Lid > 1 || (let c = (List.head lidwd.Lid).idText.[0] in Char.IsUpper(c) && not (Char.IsLower c)) 
        then mkSynPatMaybeVar lidwd (lhs parseState)
        else mkSynPatVar (List.head lidwd.Lid) }
  | constant 
      { SynPat.Const ($1,$1.Range (lhs parseState)) }
  | FALSE  
      { SynPat.Const(SynConst.Bool false,lhs parseState) } 
  | TRUE  
      { SynPat.Const(SynConst.Bool true,lhs parseState) } 
  | NULL 
      { SynPat.Null(lhs parseState) }
  | LPAREN parenPatternBody rparen 
      { let m = (lhs parseState)
        SynPat.Paren($2 m,m) } 
  | LPAREN parenPatternBody recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen()); 
        patFromParseError ($2 (rhs2 parseState 1 2)) }
  | LPAREN error rparen 
      { (* silent recovery *) SynPat.Wild (lhs parseState) }
  | LPAREN recover 
      {  reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen()); 
         SynPat.Wild (lhs parseState)}  

  
      
parenPatternBody: 
  | parenPattern 
      { (fun m -> $1) } 
  |      
      { (fun m -> SynPat.Const(SynConst.Unit,m)) } 

/* This duplicates out 'patterns' in order to give type annotations */
/* the desired precedence w.r.t. patterns, tuple patterns in particular. */
/* Duplication requried to minimize the disturbance to the grammar, */
/* in particular the expected property that "pat" parses the same as */
/* "(pat)"!  Here are some examples: */
/*    a,b                  parses as (a,b) */
/*    (a,b)           also parses as (a,b) */
/*    (a,b : t)            parses as (a, (b:t)) */
/*    a,b as t             parses as ((a,b) as t) */
/*    (a,b as t)      also parses as ((a,b) as t) */
/*    a,b | c,d            parses as ((a,b) | (c,d)) */
/*    (a,b | c,d)     also parses as ((a,b) | (c,d)) */
/*    (a : t,b)            parses as ((a:t),b) */
/*    (a : t1,b : t2)      parses as ((a:t),(b:t2)) */
/*    (a,b as nm : t)      parses as (((a,b) as nm) : t) */
/*    (a,b :: c : t)       parses as (((a,b) :: c) : t) */
/* */
/* Probably the most unexpected thing here is that 'as nm' binds the */
/* whole pattern to the left, whereas ': t' binds only the pattern */
/* immediately preceding in the tuple. */
/* */
/* Also, it is unexpected that '(a,b : t)' in a pattern binds differently to */
/* '(a,b : t)' in an expression. It's not that easy to solve that without */
/* duplicating the entire expression grammar, or making a fairly severe breaking change */
/* to the language. */
parenPattern:
  | parenPattern AS ident 
      { SynPat.Named ($1,$3,false,rhs2 parseState 1 3) }
  | parenPattern BAR parenPattern  
      { SynPat.Or($1,$3,rhs2 parseState 1 3) }
  | tupleParenPatternElements 
      { SynPat.Tuple(List.rev $1,lhs parseState) }
  | conjParenPatternElements
      { SynPat.Ands(List.rev $1,rhs2 parseState 1 3) }
  | parenPattern COLON  typeWithTypeConstraints %prec paren_pat_colon
      { let lhsm = lhs parseState 
        SynPat.Typed($1,$3,lhsm) }
  | parenPattern COLON_COLON  parenPattern 
      { SynPat.LongIdent (LongIdentWithDots(mkSynCaseName (rhs parseState 2) opNameCons,[]),None,[ SynPat.Tuple ([$1;$3],rhs2 parseState 1 3) ],lhs parseState) }
  | constrPattern { $1 }

tupleParenPatternElements:
  | tupleParenPatternElements COMMA parenPattern  
      { $3 :: $1 }
  | parenPattern COMMA parenPattern  
      { $3 :: $1 :: [] }
  
conjParenPatternElements: 
  | conjParenPatternElements AMP parenPattern 
      { $3 :: $1 }
  | parenPattern AMP parenPattern 
      { $3 :: $1 :: [] }

recordPatternElements:
  | recordPatternElementsAux { let rs,m = $1 in SynPat.Record (rs,m) }

recordPatternElementsAux: /* Fix 1190 */
  | recordPatternElement opt_seps                      
      { [$1],lhs parseState }
  | recordPatternElement seps recordPatternElementsAux 
      { let r = $1 in let (rs,dropMark) = $3 in (r :: rs),lhs parseState }

recordPatternElement:  
  | path EQUALS parenPattern { (frontAndBack $1.Lid,$3) }

listPatternElements: /* Fix 3569 */
  |                                       
      { [] }
  | parenPattern opt_seps                 
      { [$1] }
  | parenPattern seps listPatternElements 
      { $1 :: $3 }

/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */
fromAssignmentExprBlock:
  | OBLOCKBEGIN tupleExpr oblockend 
      { $2 }

typedSeqExprBlock: 
  | OBLOCKBEGIN typedSeqExpr oblockend 
      { $2 }
  | OBLOCKBEGIN typedSeqExpr recover 
      { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileExpression());
        exprFromParseError $2 }
  | typedSeqExpr 
      { $1 }

/* The lexfilter likes to insert OBLOCKBEGIN/OBLOCKEND pairs */
declExprBlock: 
  | OBLOCKBEGIN typedSeqExpr oblockend 
      { $2 }
  | declExpr 
      { $1 }

/* For some constructs the lex filter can't be sure to insert a matching OBLOCKEND, e.g. "function a -> b | c -> d" all in one line */
/* for these it only inserts a trailing ORIGHT_BLOCK_END */
typedSeqExprBlockR: 
  | typedSeqExpr ORIGHT_BLOCK_END { $1 }
  | typedSeqExpr { $1 }

typedSeqExpr: 
  | seqExpr COLON               typeWithTypeConstraints { SynExpr.Typed ($1,$3, unionRanges $1.Range $3.Range) }
  | seqExpr { $1 }

seqExpr:
  | declExpr seps seqExpr                 
      { SynExpr.Sequential(SequencePointsAtSeq,true,$1,$3,unionRanges $1.Range $3.Range) } 
  | declExpr seps                         
      { $1 }  
  | declExpr             %prec SEMICOLON 
      { $1 } 
  | declExpr THEN seqExpr %prec prec_then_before 
      { SynExpr.Sequential(SequencePointsAtSeq,false,$1,$3,unionRanges $1.Range $3.Range ) }
  | declExpr OTHEN OBLOCKBEGIN typedSeqExpr oblockend %prec prec_then_before 
      { SynExpr.Sequential(SequencePointsAtSeq,false,$1,$4,unionRanges $1.Range $4.Range) }
  | hardwhiteLetBindings %prec prec_args_error
     { let hwlb,m = $1
       let mLetKwd,isUse = match hwlb with (BindingSetPreAttrs(m,_,isUse,_,_,_))  -> m,isUse
       reportParseErrorAt mLetKwd (FSComp.SR.parsExpectedStatementAfterLet(if isUse then "use" else "let"))
       let fauxRange = m // zero width Position at end of m
       mkLocalBindings (m,hwlb,arbExpr("seqExpr",fauxRange)) }

/* Use this as the last terminal when performing error recovery */
/* The contract for using this is that (a) if EOF occurs then the */
/* the using production must report an error and (b) the using production */
/* can report an error anyway if it is helpful, e.g. "unclosed '('" (giving two errors) */
recover: 
   | error { debugPrint("recovering via error"); true }  
   | EOF { debugPrint("recovering via EOF"); false }
   
choices:
  | SELECT_OPERATOR UNDERSCORE choiceBody 
      { let mIf = (rhs parseState 1) 
        [SynExpr.Const(SynConst.Bool(true), mIf) ,$3,mIf] }
  | SELECT_OPERATOR declExpr choiceBody 
      { let mIf = (rhs parseState 1) 
        [$2,$3,mIf] }
  | SELECT_OPERATOR UNDERSCORE choiceBody choices %prec expr_if 
      { let mIf = (rhs parseState 1)
        (SynExpr.Const(SynConst.Bool(true), mIf) ,$3,mIf) :: $4 }
  | SELECT_OPERATOR declExpr choiceBody choices %prec expr_if 
      { let mIf = (rhs parseState 1)
        ($2,$3,mIf) :: $4 }

intChoices:
  | INT_SELECT_OPERATOR UNDERSCORE choiceBody 
      { let mIf = (rhs parseState 1) 
        [SynExpr.Const(SynConst.Bool(true), mIf),$3,mIf] }
  | INT_SELECT_OPERATOR declExpr choiceBody 
      { let mIf = (rhs parseState 1) 
        [$2,$3,mIf] }
  | INT_SELECT_OPERATOR UNDERSCORE choiceBody choices %prec expr_if 
      { let mIf = (rhs parseState 1)
        (SynExpr.Const(SynConst.Bool(true), mIf),$3,mIf) :: $4 }
  | INT_SELECT_OPERATOR declExpr choiceBody choices %prec expr_if 
      { let mIf = (rhs parseState 1)
        ($2,$3,mIf) :: $4 }

choiceBody: 
  | BODY_OPERATOR  declExpr %prec prec_then_if 
      { $2 }
  | OBODY_OPERATOR  OBLOCKBEGIN typedSeqExpr oblockend %prec prec_then_if 
      { $3 }
  | OBODY_OPERATOR  OBLOCKBEGIN typedSeqExpr recover %prec prec_then_if 
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileThen());
        exprFromParseError $3 }

parallel:
  | OPARALLEL_OPERATOR typedSeqExprBlock hardwhiteDefnBindingsTerminator          
      { let mWaitKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mWaitKwd $2.Range 
        let seqPt = NoSequencePointAtDoBinding 
        let e = snd(BindingSetPreAttrs(mWaitKwd,false,false,[mkSynDoBinding (true,$2,bindingSetRange)],bindingSetRange,false), $2)
        [(e,mWaitKwd)]}
  | OPARALLEL_OPERATOR typedSeqExprBlock hardwhiteDefnBindingsTerminator parallel
      { let mWaitKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mWaitKwd $2.Range 
        let seqPt = NoSequencePointAtDoBinding 
        let e = snd(BindingSetPreAttrs(mWaitKwd,false,false,[mkSynDoBinding (true,$2,bindingSetRange)],bindingSetRange,false), $2)
        (e,mWaitKwd) :: $4 }

declExpr:
  | choices
     { SynExpr.Choice(false,$1) }
  | intChoices
     { SynExpr.Choice(true,$1) }
  | parallel
     { SynExpr.Parallel($1) }
  | defnBindingsWait IN typedSeqExpr %prec expr_let 
     { mkLocalBindings (unionRanges (rhs2 parseState 1 2) $3.Range,$1,$3) }
  | defnBindings IN typedSeqExpr  %prec expr_let 
     { mkLocalBindings (unionRanges (rhs2 parseState 1 2) $3.Range,$1,$3) }
  | defnBindings IN error        %prec expr_let
     { mkLocalBindings (rhs2 parseState 1 2,$1,arbExpr("declExpr1",(rhs parseState 3))) }
/*
    FSComp.SR.parsNoMatchingInForLet() -- leave this in for now - it's an unused error string
*/
  | hardwhiteLetWaitBindings typedSeqExprBlock  %prec expr_let 
     { let hwlb,m = $1
       mkLocalBindings (unionRanges m $2.Range,hwlb,$2) }
  | hardwhiteLetBindings typedSeqExprBlock  %prec expr_let 
     { let hwlb,m = $1
       mkLocalBindings (unionRanges m $2.Range,hwlb,$2) }
  | hardwhiteLetWaitBindings error        %prec expr_let
     { let hwlb,m = $1
       reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m,_,_,_,_,_))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (m,hwlb,arbExpr("declExpr2",(rhs parseState 2))) }
  | hardwhiteLetBindings error        %prec expr_let
     { let hwlb,m = $1
       reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m,_,_,_,_,_))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (m,hwlb,arbExpr("declExpr2",(rhs parseState 2))) }
  | hardwhiteLetWaitBindings OBLOCKSEP typedSeqExprBlock  %prec expr_let 
     { let hwlb,m = $1
       mkLocalBindings (unionRanges m $3.Range ,hwlb,$3) }
  | hardwhiteLetBindings OBLOCKSEP typedSeqExprBlock  %prec expr_let 
     { let hwlb,m = $1
       mkLocalBindings (unionRanges m $3.Range ,hwlb,$3) }
  | hardwhiteLetWaitBindings OBLOCKSEP error        %prec expr_let
     { let hwlb,m = $1
       //reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m,_,_,_,_,_))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (unionRanges m (rhs parseState 3),hwlb,arbExpr("declExpr3",(rhs parseState 3))) }
  | hardwhiteLetBindings OBLOCKSEP error        %prec expr_let
     { let hwlb,m = $1
       //reportParseErrorAt (match hwlb with (BindingSetPreAttrs(m,_,_,_,_,_))  -> m) (FSComp.SR.parsErrorInReturnForLetIncorrectIndentation())
       mkLocalBindings (unionRanges m (rhs parseState 3),hwlb,arbExpr("declExpr3",(rhs parseState 3))) }

  | hardwhiteDoBinding  %prec expr_let
     { let e = snd $1
       SynExpr.Do(e,e.Range) }


  
  | OWAIT typedSeqExprBlock hardwhiteDefnBindingsTerminator          
      { let mWaitKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mWaitKwd $2.Range 
        let seqPt = NoSequencePointAtDoBinding 
        let e = snd(BindingSetPreAttrs(mWaitKwd,false,false,[mkSynDoBinding (true,$2,bindingSetRange)],bindingSetRange,false), $2)
        SynExpr.WaitStatement(e,e.Range) }

  
  | OYIELD typedSeqExprBlock hardwhiteDefnBindingsTerminator          
      { let mYieldKwd = rhs parseState 1 
        let bindingSetRange = unionRanges mYieldKwd $2.Range 
        let seqPt = NoSequencePointAtDoBinding 
        let e = snd(BindingSetPreAttrs(mYieldKwd,false,false,[mkSynDoBinding (true,$2,bindingSetRange)],bindingSetRange,false), $2)
        SynExpr.YieldStatement(e,e.Range) }

  | anonLambdaExpr  %prec expr_fun 
    {   printfn "anonLambdaExpr 1"
        $1 }

  | MATCH typedSeqExpr     withClauses              %prec expr_match 
      { let mMatch = (rhs parseState 1)
        let mWith,(clauses,mLast) = $3 
        let spBind = SequencePointAtBinding(unionRanges mMatch mWith) 
        SynExpr.Match(spBind, $2,clauses,false,unionRanges mMatch mLast) }

  | MATCH typedSeqExpr     recover               %prec expr_match 
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileMatch());
        // Produce approximate expression during error recovery 
        exprFromParseError $2 }

  | IF declExpr ifExprCases %prec expr_if 
      { let mIf = (rhs parseState 1)
        $3 $2 mIf }

  | IF declExpr ifExprCases %prec expr_if 
      { let mIf = (rhs parseState 1)
        $3 $2 mIf }


  | IF declExpr recover %prec expr_if 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsIncompleteIf()); 
        // Produce an approximate expression during error recovery. 
        // Include expressions to make sure they get type checked in case that generates useful results for intellisense. 
        // Generate a throwAway for the expression so it isn't forced to have a type 'bool' 
        // from the context it is used in. 
        exprFromParseError $2 }

  | IF recover %prec expr_if 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsIncompleteIf())
        // Produce an approximate expression during error recovery. There can still be value in doing this even
        // for this pathological case.
        let m = (rhs parseState 1)
        let mEnd = m
        let spIfToThen = SequencePointAtBinding mEnd
        exprFromParseError (SynExpr.IfThenElse(arbExpr("ifGuard1",mEnd),arbExpr("thenBody1",mEnd),None,spIfToThen,true,m,m)) }

  | WHILE declExpr doToken typedSeqExprBlock doneDeclEnd 
      { let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = SequencePointAtWhileLoop mWhileHeader 
        let mWhileAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.While(spWhile,$2,$4,mWhileAll) }
      
  | WHILE declExpr doToken typedSeqExprBlock recover 
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWhile());
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = SequencePointAtWhileLoop mWhileHeader 
        let mWhileAll = unionRanges (rhs parseState 1) $4.Range
        exprFromParseError (SynExpr.While(spWhile,$2,$4,mWhileAll)) }

  | WHILE declExpr doToken error doneDeclEnd 
      { // silent recovery 
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = SequencePointAtWhileLoop mWhileHeader 
        let mWhileBodyArb = unionRanges (rhs parseState 4) (rhs parseState 5)
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 5)
        SynExpr.While(spWhile,$2,arbExpr("whileBody1",mWhileBodyArb),mWhileAll) }

  | WHILE declExpr recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsWhileDoExpected())
        let mWhileHeader = unionRanges (rhs parseState 1) $2.Range
        let spWhile = SequencePointAtWhileLoop mWhileHeader 
        let mWhileBodyArb = rhs parseState 3
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 3)
        exprFromParseError (SynExpr.While(spWhile,$2,arbExpr("whileBody2",mWhileBodyArb),mWhileAll))  }

  | WHILE recover 
      { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWhile());
        arbExpr("whileLoop1",rhs parseState 1)  }

  | WHILE error doneDeclEnd 
      { //silent recovery
        let mWhileHeader = rhs parseState 1
        let spWhile = SequencePointAtWhileLoop mWhileHeader 
        let mWhileBodyArb = rhs parseState 3
        let mWhileAll = unionRanges (rhs parseState 1) (rhs parseState 3)
        exprFromParseError (SynExpr.While(spWhile,arbExpr("whileGuard1",mWhileHeader),arbExpr("whileBody3",mWhileBodyArb),mWhileAll))  }

  | FOR forLoopBinder doToken typedSeqExprBlock doneDeclEnd 
      { let spBind = SequencePointAtForLoop(rhs2 parseState 1 3)
        let (a,b,_) = $2 
        SynExpr.ForEach(spBind,SeqExprOnly false,true,a,b,$4,unionRanges (rhs parseState 1) $4.Range) }

  | FOR forLoopBinder doToken typedSeqExprBlock ends_coming_soon_or_recover
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let spBind = SequencePointAtForLoop(rhs2 parseState 1 3)
        let (a,b,_) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.ForEach(spBind,SeqExprOnly false,true,a,b,$4,mForLoopAll) }  

  | FOR forLoopBinder doToken error doneDeclEnd 
      { // Silent recovery
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,_) = $2 
        let mForLoopBodyArb = rhs parseState 5
        let mForLoopAll = rhs2 parseState 1 5
        SynExpr.ForEach(spBind,SeqExprOnly false,true,a,b,arbExpr("forLoopBody2a",mForLoopBodyArb),mForLoopAll) }

  | FOR forLoopBinder doToken ends_coming_soon_or_recover 
      { if not $4 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsExpectedExpressionAfterToken())
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,_) = $2 
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        SynExpr.ForEach(spBind,SeqExprOnly false,true,a,b,arbExpr("forLoopBody2",mForLoopBodyArb),mForLoopAll) }

  | FOR forLoopBinder ends_coming_soon_or_recover
      { let (a,b,ok) = $2 
        if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsForDoExpected())
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        SynExpr.ForEach(spBind,SeqExprOnly false,true,a,b,arbExpr("forLoopBody1",mForLoopBodyArb),mForLoopAll) }

  | FOR forLoopRange  doToken typedSeqExprBlock doneDeclEnd 
      { let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,c,d) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        SynExpr.For(spBind,a,b,c,d,$4,mForLoopAll) }

  | FOR forLoopRange  doToken typedSeqExprBlock recover 
      { if not $5 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor());
        // Still produce an expression
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,c,d) = $2 
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        exprFromParseError (SynExpr.For(spBind,a,b,c,d,$4,mForLoopAll)) }

  | FOR forLoopRange  doToken error doneDeclEnd 
      { // silent recovery 
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,c,d) = $2 
        let mForLoopBodyArb = rhs parseState 5
        let mForLoopAll = rhs2 parseState 1 5
        SynExpr.For(spBind,a,b,c,d,arbExpr("declExpr11",mForLoopBodyArb),mForLoopAll) }

  | FOR forLoopRange  doToken recover
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor())
        let mForLoopHeader = rhs2 parseState 1 3
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,c,d) = $2 
        let mForLoopBodyArb = rhs parseState 3
        let mForLoopAll = rhs2 parseState 1 3
        exprFromParseError (SynExpr.For(spBind,a,b,c,d,arbExpr("declExpr11",mForLoopBodyArb),mForLoopAll)) }

  | FOR forLoopRange recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor());
        let mForLoopHeader = rhs2 parseState 1 2
        let spBind = SequencePointAtForLoop mForLoopHeader
        let (a,b,c,d) = $2 
        let mForLoopBodyArb = (rhs parseState 2)
        let mForLoopAll = rhs2 parseState 1 2
        exprFromParseError (SynExpr.For(spBind,a,b,c,d,arbExpr("declExpr11",mForLoopBodyArb),mForLoopAll)) }


  | FOR error doToken typedSeqExprBlock doneDeclEnd 
      { // silent recovery 
        let mForLoopHeader = rhs2 parseState 1 2
        let mForLoopAll = unionRanges (rhs parseState 1) $4.Range
        let spBind = SequencePointAtForLoop(mForLoopHeader)
        SynExpr.For(spBind,mkSynId mForLoopHeader "_loopVar",arbExpr("startLoopRange1",mForLoopHeader),true,arbExpr("endLoopRange1",rhs parseState 3),$4,mForLoopAll) }

/* do not include this one - though for fairly bizarre reasons!
   If the user has simply typed 'for'as the 
   start of a variable name, and intellisense parsing 
   kicks in, then we can't be sure we're parsing a for-loop. The general rule is that you shoudn't
   commit to aggressive look-for-a-matching-construct error recovery until
   you're sure you're parsing a particular construct.

  This probably affects 'and' as well, but it's hard to change that.
  'for' is a particularly common prefix of identifiers.

  | FOR error doneDeclEnd {  reportParseErrorAt (rhs parseState 2)  (FSComp.SR.parsIdentifierExpected()); arbExpr("declExpr12",(lhs parseState)) }
*/
  | FOR ends_coming_soon_or_recover
      { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsIdentifierExpected())
        arbExpr("declExpr12",(rhs parseState 1)) }

  | FOR parenPattern error doneDeclEnd 
      { reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsInOrEqualExpected())
        let mForLoopHeader = rhs2 parseState 1 2
        let spBind = SequencePointAtForLoop mForLoopHeader
        let mForLoopBodyArb = rhs parseState 4
        let mForLoopAll = rhs2 parseState 1 4
        SynExpr.ForEach(spBind,SeqExprOnly false,true,$2,arbExpr("forLoopCollection",mForLoopHeader),arbExpr("forLoopBody3",mForLoopBodyArb),mForLoopAll) }

  | FOR parenPattern recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileFor());
        let mForLoopHeader = rhs2 parseState 1 2
        let spBind = SequencePointAtForLoop mForLoopHeader
        let mForLoopBodyArb = (rhs parseState 2)
        let mForLoopAll = rhs2 parseState 1 2
        exprFromParseError (SynExpr.ForEach(spBind,SeqExprOnly false,true,$2,arbExpr("forLoopCollection",mForLoopHeader),arbExpr("forLoopBody3",mForLoopBodyArb),mForLoopAll)) }

  | FOR forLoopBinder opt_OBLOCKSEP monadicSingleLineQualifiersThenArrowThenExprR %prec expr_let 
     { let spBind = SequencePointAtForLoop(rhs2 parseState 1 2)
       let (a,b,_) = $2 in SynExpr.ForEach(spBind,SeqExprOnly true,true,a,b,$4,unionRanges (rhs parseState 1) $4.Range) }

  | declExpr COLON_GREATER       typ  { SynExpr.Upcast($1,$3, unionRanges $1.Range $3.Range) } 

  /* NOTE: any change to the "INFIX" tokens (or their definitions) should be reflected in PrettyNaming.IsInfixOperator */
  | declExpr COLON_EQUALS           declExpr { mkSynInfix (rhs parseState 2) $1 ":=" $3 }
/*   | minusExpr LARROW                recover { mkSynAssign $1 (arbExpr("assignRhs",rhs parseState 2)) } */
  | tupleExpr  %prec expr_tuple  { let exprs,commas = $1 in SynExpr.Tuple(List.rev exprs, List.rev commas, (commas.Head, exprs) ||> unionRangeWithListBy (fun e -> e.Range) ) }
  

  
  | declExpr  JOIN_IN               declExpr { SynExpr.JoinIn($1,rhs parseState 2,$3,unionRanges $1.Range $3.Range) }
  | declExpr  BAR_BAR               declExpr { mkSynInfix (rhs parseState 2) $1 "||" $3 }
  | declExpr  INFIX_BAR_OP          declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  OR                    declExpr { mkSynInfix (rhs parseState 2) $1 "or" $3 }
  | declExpr  AMP                   declExpr { mkSynInfix (rhs parseState 2) $1 "&" $3 }
  | declExpr  AMP_AMP               declExpr { mkSynInfix (rhs parseState 2) $1 "&&" $3 }
  | declExpr  INFIX_AMP_OP          declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  EQUALS                declExpr { mkSynInfix (rhs parseState 2) $1 "=" $3 }
  | declExpr  INFIX_COMPARE_OP      declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  DOLLAR                declExpr { mkSynInfix (rhs parseState 2) $1 "$" $3 }
  | declExpr  LESS                  declExpr { mkSynInfix (rhs parseState 2) $1 "<" $3 }
  | declExpr  GREATER               declExpr { mkSynInfix (rhs parseState 2) $1 ">" $3 }
  | declExpr  INFIX_AT_HAT_OP       declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  PERCENT_OP            declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  COLON_COLON           declExpr { SynExpr.App (ExprAtomicFlag.NonAtomic, true, mkSynIdGet (rhs parseState 2) opNameCons,SynExpr.Tuple ([$1;$3],[rhs parseState 2],unionRanges $1.Range $3.Range),unionRanges $1.Range $3.Range) }
  | declExpr  PLUS_MINUS_OP         declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  MINUS                 declExpr { mkSynInfix (rhs parseState 2) $1 "-" $3 }
  | declExpr  STAR                  declExpr { mkSynInfix (rhs parseState 2) $1 "*" $3 }
  | declExpr  INFIX_STAR_DIV_MOD_OP declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }
  | declExpr  INFIX_STAR_STAR_OP    declExpr { mkSynInfix (rhs parseState 2) $1 $2 $3 }

  | declExpr  JOIN_IN               OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("in")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "@in" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  BAR_BAR               OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("||")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "||" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_BAR_OP          OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  OR                    OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("or")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "or" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  AMP                   OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("&")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "&" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  AMP_AMP               OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("&&")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "&&" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_AMP_OP          OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  EQUALS                OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("=")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "=" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_COMPARE_OP      OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  DOLLAR                OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("$")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "$" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  LESS                  OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("<")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "<" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  GREATER               OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression(">")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 ">" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_AT_HAT_OP       OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  PERCENT_OP            OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  COLON_COLON           OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("::")); 
                                                            SynExpr.App (ExprAtomicFlag.NonAtomic, true, mkSynIdGet (rhs parseState 2) opNameCons,SynExpr.Tuple ([$1;(arbExpr("declExprInfix",(rhs parseState 3)))],[rhs parseState 2],unionRanges $1.Range (rhs parseState 3)),unionRanges $1.Range (rhs parseState 3)) }
  | declExpr  PLUS_MINUS_OP         OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  MINUS                 OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("-")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "-" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  STAR                  OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression("*")); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 "*" (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_STAR_DIV_MOD_OP OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }
  | declExpr  INFIX_STAR_STAR_OP    OBLOCKEND_COMING_SOON { reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnfinishedExpression($2)); 
                                                            exprFromParseError(mkSynInfix (rhs parseState 2) $1 $2 (arbExpr("declExprInfix",(rhs parseState 3)))) }

  | minusExpr %prec expr_prefix_plus_minus { $1 }


dynamicArg:
  | IDENT
      { let con = SynConst.String ($1,rhs parseState 1)
        let arg2 = SynExpr.Const (con,con.Range (rhs parseState 1)) 
        arg2 }
  | LPAREN typedSeqExpr rparen
      { $2 }

withClauses:
  | WITH withPatternClauses       
      { rhs parseState 1, $2 }
  | OWITH withPatternClauses OEND 
      { rhs parseState 1, $2 }
  | OWITH withPatternClauses recover 
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileWith());
        rhs parseState 1, $2 }

withPatternClauses:
  | patternClauses 
      { $1 }
  | BAR patternClauses 
      {  $2 }
  | BAR error 
      {  // silent recovery 
         let mLast = rhs parseState 1
         [], mLast }
  | error  
      {  // silent recovery 
         let mLast = rhs parseState 1
         [], mLast }


patternAndGuard: 
  | parenPattern patternGuard 
      { $1, $2, rhs parseState 1 }
      
patternClauses: 
  | patternAndGuard patternResult %prec prec_pat_pat_action
     { let pat,guard,patm = $1 
       let mLast = $2.Range 
       [Clause(pat,guard,$2,patm,SequencePointAtTarget)], mLast  }
  | patternAndGuard patternResult BAR patternClauses 
     { let pat,guard,patm = $1 
       let clauses,mLast = $4 
       (Clause(pat,guard,$2,patm,SequencePointAtTarget) :: clauses), mLast }
  | patternAndGuard patternResult BAR error 
     { let pat,guard,patm = $1 
       let mLast = rhs parseState 3 
       // silent recovery 
       [Clause(pat,guard,$2,patm,SequencePointAtTarget)], mLast  }
  | patternAndGuard patternResult error 
     { let pat,guard,patm = $1 
       let mLast = $2.Range 
       // silent recovery 
       [Clause(pat,guard,$2,patm,SequencePointAtTarget)], mLast }
  | patternAndGuard error 
     { let pat,guard,patm = $1 
       let mLast = rhs parseState 2
       // silent recovery 
       [Clause(pat,guard,SynExpr.Const(SynConst.Unit,mLast),patm,SequencePointAtTarget)], mLast }
 
patternGuard: 
  | WHEN declExpr 
     { Some $2 }
  | 
     { None }

patternResult: 
  | RARROW typedSeqExprBlockR  
     { $2 }

fromExprCondition:
  //| tupleExpr  %prec expr_tuple  { let exprs,commas = $1 in SynExpr.Tuple(List.rev exprs, List.rev commas, (commas.Head, exprs) ||> unionRangeWithListBy (fun e -> e.Range) ) }
  //| forLoopBinder { SynExpr.Tuple(List.rev exprs, List.rev commas, (commas.Head, exprs) ||> unionRangeWithListBy (fun e -> e.Range) ) }
  | fromTupleExpr { let exprs = $1 
                    exprs }
  

  

ifExprCases: 
  | ifExprThen ifExprElifs 
      { let exprThen,mThen = $1 
        (fun exprGuard mIf -> 
            let mIfToThen = unionRanges mIf mThen
            let lastBranch : SynExpr = match $2 with None -> exprThen | Some e -> e
            let mIfToEndOfLastBranch = unionRanges mIf lastBranch.Range
            let spIfToThen = SequencePointAtBinding(mIfToThen)
            SynExpr.IfThenElse(exprGuard,exprThen,$2,spIfToThen,false,mIfToThen,mIfToEndOfLastBranch)) }

ifExprThen: 
  | THEN  declExpr %prec prec_then_if 
      { $2, rhs parseState 1 }
  | OTHEN  OBLOCKBEGIN typedSeqExpr oblockend %prec prec_then_if 
      { $3,rhs parseState 1 }
  | OTHEN  OBLOCKBEGIN typedSeqExpr recover %prec prec_then_if 
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileThen());
        exprFromParseError $3,rhs parseState 1 }

ifExprElifs: 
  | 
      { None }
  | ELSE declExpr 
      { Some $2 }
  | OELSE  OBLOCKBEGIN typedSeqExpr oblockend 
      { Some $3 }
  | OELSE  OBLOCKBEGIN typedSeqExpr recover 
      { if not $4 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileElse());
        Some (exprFromParseError $3) }
  | ELIF declExpr ifExprCases 
      { let mElif = rhs parseState 1 
        Some ($3 $2 mElif) }
  | ELIF declExpr recover 
      { Some (exprFromParseError $2) }


tuplePat:
  | tuplePat COMMA nameop
      { let patterns,commas = $1 in ($3 :: patterns),((rhs parseState 2)::commas) }
  /*| tuplePat COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let patterns,commas = $1     
        let zeroWidthAtNextToken = (rhs parseState 3)
        ((arbExpr("tupleExpr1",zeroWidthAtNextToken)) :: patterns), (rhs parseState 2)::commas }
  | parenPattern COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let zeroWidthAtNextToken = (rhs parseState 3) 
        ((arbExpr("tupleExpr2",zeroWidthAtNextToken)) :: [$1]), [rhs parseState 2] }*/
  | nameop COMMA nameop  
      { [$3 ; $1], [rhs parseState 2] }

tupleExpr:
  | tupleExpr COMMA declExpr
      { let exprs,commas = $1 in ($3 :: exprs),((rhs parseState 2)::commas) }
  /*| tupleExpr COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let exprs,commas = $1     
        let zeroWidthAtNextToken = (rhs parseState 3)
        ((arbExpr("tupleExpr1",zeroWidthAtNextToken)) :: exprs), (rhs parseState 2)::commas }
  | declExpr COMMA ends_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
        let zeroWidthAtNextToken = (rhs parseState 3) 
        ((arbExpr("tupleExpr2",zeroWidthAtNextToken)) :: [$1]), [rhs parseState 2] }*/
  | declExpr COMMA declExpr  
      { [$3 ; $1], [rhs parseState 2] }

minusExpr: 
  | MINUS minusExpr   %prec expr_prefix_plus_minus
      { mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) "~-" $2 }
  | PLUS_MINUS_OP minusExpr  
      { if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt $2.Range (FSComp.SR.parsInvalidPrefixOperator());
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) ("~"^($1)) $2 } 
  | PERCENT_OP minusExpr
      { if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt $2.Range (FSComp.SR.parsInvalidPrefixOperator());
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) $2.Range) ("~"^($1)) $2 }
  | NEW appTypeNonAtomicDeprecated  opt_HIGH_PRECEDENCE_APP atomicExprAfterType 
      { SynExpr.New(false,$2,$4,unionRanges (rhs parseState 1) $4.Range) }
  | NEW appTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP error   
      { SynExpr.New(false,$2,arbExpr("minusExpr",(rhs parseState 4)),unionRanges (rhs parseState 1) ($2).Range) }
  | NEW error
      { arbExpr("minusExpr2",(rhs parseState 1)) }
  | UPCAST  minusExpr 
      { SynExpr.InferredUpcast($2,unionRanges (rhs parseState 1) $2.Range) }     
  | appExpr 
     { $1 }

appExpr:
  | appExpr argExpr %prec expr_app
      { SynExpr.App (ExprAtomicFlag.NonAtomic, false, $1,$2,unionRanges $1.Range $2.Range)  }
  | atomicExpr 
      { let arg,_ = $1 
        arg }

argExpr:
  | ADJACENT_PREFIX_OP atomicExpr 
      { let arg2,hpa2 = $2 
        if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt arg2.Range (FSComp.SR.parsInvalidPrefixOperator());
        if hpa2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled());
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) arg2.Range) ("~"^($1)) arg2 }
   | atomicExpr 
      { let arg,hpa = $1 
        if hpa then reportParseErrorAt arg.Range (FSComp.SR.parsSuccessiveArgsShouldBeSpacedOrTupled());
        arg }
    
    
atomicExpr:
  | atomicExpr HIGH_PRECEDENCE_BRACK_APP atomicExpr
      { let arg1,_ = $1 
        let arg2,_ = $3 
        SynExpr.App (ExprAtomicFlag.Atomic, false, arg1,arg2,unionRanges arg1.Range arg2.Range),true  }

  | atomicExpr HIGH_PRECEDENCE_PAREN_APP atomicExpr
      { let arg1,_ = $1 
        let arg2,_ = $3 
        SynExpr.App (ExprAtomicFlag.Atomic, false, arg1,arg2,unionRanges arg1.Range arg2.Range),true  }

  | atomicExpr HIGH_PRECEDENCE_TYAPP typeArgsActual
      { let arg1,_ = $1 
        let mLessThan,mGreaterThan,_,args,commas,mTypeArgs = $3
        let mWholeExpr = unionRanges arg1.Range mTypeArgs
        SynExpr.TypeApp(arg1, mLessThan, args, commas, mGreaterThan, mTypeArgs, mWholeExpr), false }

  | PREFIX_OP  atomicExpr  
      { let arg2,hpa2 = $2 
        if not (IsValidPrefixOperatorUse $1) then reportParseErrorAt arg2.Range (FSComp.SR.parsInvalidPrefixOperator());
        mkSynPrefix (rhs parseState 1) (unionRanges (rhs parseState 1) arg2.Range) $1 arg2,hpa2 }

  | atomicExpr DOT atomicExprQualification 
      { let arg1,hpa1 = $1 
        $3 arg1 (lhs parseState) (rhs parseState 2),hpa1 }
  | BASE DOT atomicExprQualification 
      { let arg1 = SynExpr.Ident(ident("base",rhs parseState 1))
        $3 arg1 (lhs parseState) (rhs parseState 2),false }
  | QMARK nameop 
      { SynExpr.LongIdent (true,LongIdentWithDots([$2],[]),None,rhs parseState 2),false }
  | atomicExpr QMARK dynamicArg
      { let arg1,hpa1 = $1
        mkSynInfix (rhs parseState 2) arg1 "?" $3, hpa1 }
  | GLOBAL
      { SynExpr.Ident (ident(MangledGlobalName,rhs parseState 1)), false }
  | nameop
      { SynExpr.Ident ($1),false }
  | LBRACK listExprElements RBRACK 
      { $2 (lhs parseState) false,false }
  | LBRACK listExprElements recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()); 
        exprFromParseError ($2 (rhs2 parseState 1 2) false), false }
  | LBRACK error RBRACK 
      { // silent recovery 
        SynExpr.ArrayOrList(false,[ ], lhs parseState),false  } 
  | LBRACK recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()); 
        // silent recovery 
        exprFromParseError (SynExpr.ArrayOrList(false,[ ], rhs parseState 1)),false  } 
  | atomicExprAfterType 
      { $1,false }
  
atomicExprQualification:
  |    identOrOp 
      { let idm = rhs parseState 1 
        (fun e lhsm dotm -> mkSynDot dotm lhsm e $1) }
  |    CREATE
      { let idm = rhs parseState 1 
        (fun e lhsm dotm -> mkSynDot dotm lhsm e (Ident("Create",idm))) }
  |   /* empty */
      { (fun e lhsm dotm -> 
            reportParseErrorAt dotm (FSComp.SR.parsMissingQualificationAfterDot()); 
            let fixedLhsm = mkRange lhsm.FileName lhsm dotm // previous lhsm is wrong after 'recover'
            mkSynDotMissing dotm fixedLhsm e) }
  |  recover 
      { (fun e lhsm dotm -> 
            reportParseErrorAt dotm (FSComp.SR.parsMissingQualificationAfterDot()); 
            let fixedLhsm = mkRange lhsm.FileName lhsm dotm // previous lhsm is wrong after 'recover'
            // Include 'e' in the returned expression but throw it away
            SynExpr.DiscardAfterMissingQualificationAfterDot(e,fixedLhsm)) }
  |   LPAREN  typedSeqExpr rparen  
      { (fun e lhsm dotm -> 
            mlCompatWarning (FSComp.SR.parsParenFormIsForML()) (lhs parseState); 
            mkSynDotParenGet lhsm dotm e $2) }
  |   LBRACK  typedSeqExpr RBRACK  
      { (fun e lhsm dotm -> mkSynDotBrackGet lhsm dotm e $2) }

  |   LBRACK  typedSeqExpr recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket()); 
        (fun e lhsm dotm -> exprFromParseError (mkSynDotBrackGet lhsm dotm e $2)) }

  |   LBRACK  error RBRACK  
      { let mArg = rhs2 parseState 1 3
        (fun e lhsm dotm -> mkSynDotBrackGet lhsm dotm e (arbExpr("indexerExpr1",mArg))) }
  |   LBRACK  recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracket())
        let mArg = (rhs parseState 1) 
        (fun e lhsm dotm -> exprFromParseError (mkSynDotBrackGet lhsm dotm e (arbExpr("indexerExpr2",mArg)))) }
  |   LBRACK  optRange RBRACK  
      { (fun e lhsm dotm -> mkSynDotBrackSliceGet lhsm dotm e $2) }

optRange:
  | declExpr DOT_DOT declExpr 
      { mkSynOptionalExpr (rhs parseState 1) (Some $1), mkSynOptionalExpr (rhs parseState 3) (Some $3) }
  | declExpr DOT_DOT 
      { mkSynOptionalExpr (rhs parseState 1) (Some $1), mkSynOptionalExpr (rhs parseState 2) None }
  | DOT_DOT declExpr 
      { mkSynOptionalExpr (rhs parseState 1) None, mkSynOptionalExpr (rhs parseState 2) (Some $2) }
  | STAR 
      { mkSynOptionalExpr (rhs parseState 1) None, mkSynOptionalExpr (rhs parseState 1) None }
  

/* the start et of atomicExprAfterType must not overlap with the valid postfix tokens of the type syntax, e.g. new List<T>(...) */
atomicExprAfterType:
  | constant 
      { SynExpr.Const ($1,$1.Range (lhs parseState)) }
  | parenExpr 
      { $1 }
  | braceExpr 
      { $1 }
  | NULL 
      { SynExpr.Null(lhs parseState) } 
  | FALSE  
      { SynExpr.Const(SynConst.Bool false,lhs parseState) } 
  | TRUE  
      { SynExpr.Const(SynConst.Bool true,lhs parseState) } 
  | arrayExpr
      { $1 }
  | beginEndExpr
      { $1 }
  
beginEndExpr:
  | BEGIN typedSeqExpr END 
      { SynExpr.Paren($2, rhs parseState 1, Some(rhs parseState 3), rhs2 parseState 1 3) } 
  | BEGIN typedSeqExpr recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBegin()); exprFromParseError $2 } 
  | BEGIN error END 
      { (* silent recovery *) arbExpr("beginEndExpr",(lhs parseState))  } 
  | BEGIN END 
      { mkSynUnit (lhs parseState) } 

arrayExpr:
  | LBRACK_BAR listExprElements BAR_RBRACK 
      {  $2 (lhs parseState) true } 
  | LBRACK_BAR listExprElements recover 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracketBar()); 
        exprFromParseError ($2 (rhs2 parseState 1 2) true) }
  | LBRACK_BAR error BAR_RBRACK 
      {  (* silent recovery *) SynExpr.ArrayOrList(true,[ ], lhs parseState) }  
  | LBRACK_BAR recover
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBracketBar());  
        (* silent recovery *) 
        exprFromParseError (SynExpr.ArrayOrList(true,[ ], rhs parseState 1)) }  

parenExpr:
  | LPAREN rparen 
      { SynExpr.Const(SynConst.Unit,(rhs2 parseState 1 2)) } 
  | LPAREN parenExprBody rparen
      { let m = rhs2 parseState 1 3
        SynExpr.Paren($2 m, rhs parseState 1, Some(rhs parseState 3), m) }
  | LPAREN parenExprBody ends_other_than_rparen_coming_soon_or_recover
      { if not $3 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 3)
        SynExpr.Paren(exprFromParseError ($2 lhsm), rhs parseState 1, None, lhsm) }
  | LPAREN error rparen 
      { // silent recovery
        SynExpr.Paren(arbExpr("parenExpr1",(rhs parseState 1)),(rhs parseState 1),Some(rhs parseState 3),(rhs2 parseState 1 3)) } 
  | LPAREN TYPE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2)
        arbExpr("parenExpr2tcs", lhsm) }
  | LPAREN MODULE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2)
        arbExpr("parenExpr2mcs", lhsm) }
  | LPAREN RBRACE_COMING_SOON
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2)
        arbExpr("parenExpr2rbcs", lhsm) }
  | LPAREN OBLOCKEND_COMING_SOON 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen())
        let lhsm = unionRangeWithPos (rhs parseState 1) (rhs parseState 2)
        arbExpr("parenExpr2obecs", lhsm) }
  | LPAREN recover %prec prec_atomexpr_lparen_error 
      { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen()); 
        arbExpr("parenExpr2",(lhs parseState))  }  

        // This is really what we should be doing, but it fails because param info expects the Position of the expression
        // to extend all the way over the "recover", to the end of the file if necessary
        // 
        // let mLeftParen = rhs parseState 1
        //let lhsm = if $2 then unionRangeWithPos mLeftParen (rhs parseState 2).Start else mLeftParen
        //arbExpr("parenExpr2",lhsm)  }  

parenExprBody:
  | typedSeqExpr
      { (fun _m -> $1) } 

staticallyKnownHeadTypars:
  | staticallyKnownHeadTypar 
      { [$1] }
  | LPAREN staticallyKnownHeadTyparAlts rparen 
      { List.rev $2 }

staticallyKnownHeadTyparAlts:
	| staticallyKnownHeadTyparAlts OR staticallyKnownHeadTypar
      {$3 :: $1}
    | staticallyKnownHeadTypar
      { [$1] }

braceExpr:
  | LBRACE braceExprBody rbrace 
     {  let m,r = $2 in r (rhs2 parseState 1 3) }
  | LBRACE braceExprBody recover 
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace()) ; 
       let m,r = $2 
       // Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions
       r (unionRanges (rhs parseState 1) m) }
  | LBRACE error rbrace 
     { // silent recovery 
       arbExpr("braceExpr",rhs2 parseState 1 3)  }  
  | LBRACE recover
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedBrace()) ; 
       // Note, we can't use 'exprFromParseError' because the extra syntax node interferes with some syntax-directed transformations for computation expressions
       SynExpr.Record(None,None,[],rhs parseState 1) }
  | LBRACE rbrace 
     {  let m = rhs2 parseState 1 2 
        SynExpr.Record(None,None,[],m) }

braceExprBody:
  | recdExpr 
     {  (lhs parseState), (fun m -> let a,b,c = $1 in SynExpr.Record(a,b,c,m)) }
  | monadicExprInitial 
     { let m,r = $1 in (m, r false) }

monadicExprBody:
  | monadicExprInitial 
     { let m,r = $1 in (m, r false) }

listExprElements: 
  | monadicExprInitial
     { let m,r = $1 in (fun lhsm isArray -> SynExpr.ArrayOrListOfSeqExpr(isArray, r true m, lhsm)) }
  | 
     { (fun lhsm isArray -> SynExpr.ArrayOrList(isArray,[ ], lhsm)) }

monadicExprInitial: 
  | seqExpr
     { $1.Range, (fun isArrayOrList lhsm -> SynExpr.CompExpr(isArrayOrList,ref(isArrayOrList),$1,lhsm)) }
  | rangeSequenceExpr 
     { $1 }
  
rangeSequenceExpr: 
  | declExpr DOT_DOT  declExpr  
     { let opm = (rhs parseState 2)
       (unionRanges $1.Range $3.Range),(fun _isArray wholem -> 
                                                // in the case of "{ 1 .. 10 }", we want the Position of the expression to include the curlies, that comes from a higher level rule in the grammar,
                                                // passed down as 'wholem', so patch up that Position here
                                                match (mkSynInfix opm $1 ".." $3) with
                                                | SynExpr.App(a,b,c,d,_) -> SynExpr.App(a,b,c,d,wholem)
                                                | _ -> failwith "impossible") }
  | declExpr DOT_DOT  declExpr DOT_DOT declExpr  
     { (unionRanges $1.Range $5.Range),(fun _isArray wholem -> mkSynTrifix wholem ".. .." $1 $3 $5) }

  | declExpr DOT_DOT recover  
     { if not $3 then reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileExpression());
       let opm = (rhs parseState 2)
       let e = arbExpr("rangeSeqError1", (rhs parseState 3))
       (unionRanges $1.Range e.Range),(fun _isArray wholem -> 
                                                // in the case of "{ 1 .. 10 }", we want the Position of the expression to include the curlies, that comes from a higher level rule in the grammar,
                                                // passed down as 'wholem', so patch up that Position here
                                                match (mkSynInfix opm $1 ".." e) with
                                                | SynExpr.App(a,b,c,d,_) -> SynExpr.App(a,b,c,d,wholem)
                                                | _ -> failwith "impossible") }


/* Allow a naked yield (no "yield" or "return" or "->") immediately after a "->" */
/* Allow a naked yield (no "yield!" or "return!" or "->>") immediately after a "->>" */
/* In both cases multiple 'for' and 'when' bindings can precede */
monadicSingleLineQualifiersThenArrowThenExprR:
  | RARROW typedSeqExprBlockR 
     { SynExpr.YieldOrReturn((true,false), $2, unionRanges (rhs parseState 1) $2.Range) }



forLoopBinder: 
  | parenPattern IN declExpr 
     { ($1, $3, true) }
  | parenPattern IN rangeSequenceExpr 
     { let m,r = $3 in ($1, r false m, true) }
  | parenPattern IN ends_coming_soon_or_recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
       ($1, arbExpr("forLoopBinder",(rhs parseState 2)), false) }
  | parenPattern ends_coming_soon_or_recover
     { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInOrEqualExpected())
       ($1, arbExpr("forLoopBinder2",(rhs parseState 1)), false) }

fromLoopBinder: 
  | parenPattern LARROW declExpr 
     { ($1, $3) }
  | parenPattern LARROW rangeSequenceExpr 
     { let m,r = $3 in ($1, r false m) }
  | parenPattern LARROW ends_coming_soon_or_recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
       ($1, arbExpr("forLoopBinder",(rhs parseState 2))) }
  | parenPattern ends_coming_soon_or_recover
     { if not $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsInOrEqualExpected())
       ($1, arbExpr("forLoopBinder2",(rhs parseState 1))) }

fromTupleExpr:
  | fromTupleExpr BAR fromLoopBinder
      { let exprs = $1
        let exprs = exprs
        $3 :: exprs }
  //| fromTupleExpr COMMA ends_coming_soon_or_recover
  //    { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
  //      let exprs,commas = $1     
  //      let zeroWidthAtNextToken = (rhs parseState 3)
  //      ((arbExpr("tupleExpr1",zeroWidthAtNextToken)) :: exprs), (rhs parseState 2)::commas }
  //| fromLoopBinder COMMA ends_coming_soon_or_recover
  //    { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedExpressionAfterToken())
  //      let zeroWidthAtNextToken = (rhs parseState 3) 
  //      ((arbExpr("tupleExpr2",zeroWidthAtNextToken)) :: [$1]), [rhs parseState 2] }*)
  | fromLoopBinder
      { [$1] }
  | fromLoopBinder BAR fromLoopBinder  
      { [$3 ; $1] }

forLoopRange: 
  | parenPattern EQUALS declExpr  forLoopDirection  declExpr 
      { idOfPat (rhs parseState 1) $1,$3,$4,$5 }
  
opt_curriedArgExprs: 
  | opt_curriedArgExprs argExpr  %prec expr_args { $2 :: $1 } 
  |  { [] }

opt_atomicExprAfterType: 
  |  { None }
  |  atomicExprAfterType { Some($1) }

recdExpr:
  | INHERIT appTypeNonAtomicDeprecated opt_HIGH_PRECEDENCE_APP opt_atomicExprAfterType recdExprBindings opt_seps_recd
     { let arg = match $4 with None -> mkSynUnit (lhs parseState) | Some e -> e 
       let l = List.rev $5
       let dummyField = mkRecdField (LongIdentWithDots([], [])) // dummy identifier, it will be discarded
       let l = rebindRanges (dummyField, None) l $6 
       let (_, _, inheritsSep) = List.head l
       let bindings = List.tail l
       (Some ($2,arg,rhs2 parseState 2 4, inheritsSep, rhs parseState 1), None, bindings) }

  | appExpr EQUALS declExprBlock recdExprBindings opt_seps_recd
     { match $1 with 
       
       | LongOrSingleIdent(false, (LongIdentWithDots(_,_) as f),None,m) ->  
            let f = mkRecdField f
            let l = List.rev $4
            let l = rebindRanges (f, Some $3) l $5
            (None, None, l)
       | _ -> raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsFieldBinding()) }

/*
    handles cases when identifier can start from the underscore
*/

  | UNDERSCORE
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())
      reportParseErrorAt m (FSComp.SR.parsFieldBinding())
      let f = mkUnderscoreRecdField m
      (None, None, [ f, None, None  ]) }

  | UNDERSCORE EQUALS
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())      
      let f = mkUnderscoreRecdField m

      reportParseErrorAt (rhs2 parseState 1 2) (FSComp.SR.parsFieldBinding())
      
      (None, None, [f, None, None]) }

  | UNDERSCORE EQUALS declExprBlock recdExprBindings opt_seps_recd
    { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnderscoreInvalidFieldName())
      let f = mkUnderscoreRecdField (rhs parseState 1)

      let l = List.rev $4
      let l = rebindRanges (f, Some $3) l $5
      (None, None, l) }
/*
    handles case like {x with}
*/
  | appExpr WITH recdBinding recdExprBindings opt_seps_recd
     {  let l = List.rev $4
        let l = rebindRanges $3 l $5
        (None,Some ($1, (rhs parseState 2, None)), l) }

  | appExpr OWITH opt_seps_recd OEND
     { 
        (None,Some ($1, (rhs parseState 2, None)), []) }

  | appExpr OWITH recdBinding recdExprBindings opt_seps_recd OEND
     { 
        let l = List.rev $4
        let l = rebindRanges $3 l $5
        (None,Some ($1, (rhs parseState 2, None)), l) }

opt_seps_recd:
  | seps_recd { Some $1 }
  | { None }

seps_recd:
  | OBLOCKSEP { (rhs parseState 1), None }
  | SEMICOLON  { let m = (rhs parseState 1) in (m, Some m) }
  | SEMICOLON OBLOCKSEP { (rhs2 parseState 1 2), Some (rhs parseState 1) }
  | OBLOCKSEP SEMICOLON { (rhs2 parseState 1 2), Some (rhs parseState 2) }

/*
    identifier can start from the underscore
*/
pathOrUnderscore :
  | path { mkRecdField $1 }
  | UNDERSCORE 
    { let m = rhs parseState 1
      reportParseErrorAt m (FSComp.SR.parsUnderscoreInvalidFieldName())
      mkUnderscoreRecdField m }

recdExprBindings: 
  | recdExprBindings seps_recd recdBinding
     { ($3, Some $2) :: $1 }
  |  { [] }

recdBinding:
    | pathOrUnderscore EQUALS declExprBlock
      { ($1, Some $3) }
    | pathOrUnderscore EQUALS
      {
        reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
        ($1, None)
      }
    | pathOrUnderscore EQUALS ends_coming_soon_or_recover
      {
        reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
        ($1, None)
      }
    | pathOrUnderscore
      {
        reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
        ($1, None)
      }
    | pathOrUnderscore ends_coming_soon_or_recover
      {
        reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsFieldBinding())
        ($1, None)
      }

/* There is a minor conflict between
       seq { new ty() }  // sequence expression with one very odd 'action' expression
  and 
       { new ty() }   // object expression with no interfaces and no overrides
Hence we make sure the latter is not permitted by the grammar
*/

forLoopDirection: 
  | TO     { true } 
  | DOWNTO { false }

/*--------------------------------------------------------------------------*/
/* TYPE ALGEBRA                                                             */

typeWithTypeConstraints:
  | typ %prec prec_wheretyp_prefix { $1 }

topTypeWithTypeConstraints: 
  | topType 
     { $1 }

opt_topReturnTypeWithTypeConstraints: 
  |             
     { None } 
  | COLON topTypeWithTypeConstraints 
     { let ty,arity = $2 
       let arity = (match arity with SynValInfo([],rmdata)-> rmdata | _ -> SynInfo.unnamedRetVal)
       Some (SynReturnInfo((ty,arity),rhs parseState 2)) }

topType: 
  | topTupleType RARROW topType 
     { let dty,dmdata= $1 
       let rty,(SynValInfo(dmdatas,rmdata)) = $3 
       SynType.Fun(dty,rty,lhs parseState), (SynValInfo(dmdata::dmdatas, rmdata)) }
  | topTupleType 
     { let ty,rmdata = $1 in ty, (SynValInfo([],(match rmdata with [md] -> md | _ -> SynInfo.unnamedRetVal))) }

topTupleType:
  | topAppType STAR topTupleTypeElements 
     { let ty,mdata = $1 in let tys,mdatas = List.unzip $3 in (SynType.Tuple(List.map (fun ty -> (false,ty)) (ty ::tys), lhs parseState)),(mdata :: mdatas) }
  | topAppType                 
     { let ty,mdata = $1 in ty,[mdata] }

topTupleTypeElements:
  | topAppType STAR topTupleTypeElements       { $1 :: $3 }
  | topAppType %prec prec_toptuptyptail_prefix { [$1] }

/* REVIEW: why can't we use opt_attributes here? */
topAppType:
  | appType COLON appType 
     { match $1 with 
       | SynType.LongIdent(LongIdentWithDots([id],_)) -> $3,SynArgInfo(false,Some id)
       | _ -> raiseParseErrorAt (rhs parseState 1) (FSComp.SR.parsSyntaxErrorInLabeledType())  }
  | QMARK ident COLON appType 
     { $4,SynArgInfo(true,Some $2) }
  | appType 
     { ($1,SynArgInfo(false,None)) }
  | appType COLON appType 
     { match $1 with 
       | SynType.LongIdent(LongIdentWithDots([id],_)) -> $3,SynArgInfo(false,Some id)
       | _ -> raiseParseErrorAt (rhs parseState 2) (FSComp.SR.parsSyntaxErrorInLabeledType())  }
  | QMARK ident COLON appType 
     { $4,SynArgInfo(true,Some $2) }
  | appType 
     { $1,SynArgInfo(false,None) }

/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
typ:
  | tupleType RARROW typ  { SynType.Fun($1,$3,lhs parseState) }
  | tupleType %prec prec_typ_prefix { $1 }


tupleType:
  | appType STAR tupleOrQuotTypeElements { SynType.Tuple((false,$1) :: $3,lhs parseState) }

  | INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements
    { if $1 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
      SynType.Tuple((true, SynType.StaticConstant (SynConst.Int32 1, lhs parseState)):: $2, lhs parseState) }

  | appType INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements
      { if $2 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
        SynType.Tuple((true,$1) :: $3, lhs parseState) }
  | appType %prec prec_tuptyp_prefix { $1 }

tupleOrQuotTypeElements:
  | appType STAR tupleOrQuotTypeElements              { (false,$1) :: $3 }
  | appType INFIX_STAR_DIV_MOD_OP tupleOrQuotTypeElements 
      { if $2 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedInfixOperator());
        (true,$1) :: $3 }
  | appType %prec prec_tuptyptail_prefix { [(false,$1)] }

tupleTypeElements:
  | appType STAR tupleTypeElements              { $1 :: $3 }
  | appType %prec prec_tuptyptail_prefix { [$1] }

appTypeCon:
  | path %prec prec_atomtyp_path 
      { SynType.LongIdent($1) }

appTypeConPower:
  | appTypeCon INFIX_AT_HAT_OP INT32
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       if $2 = "^-" then SynType.MeasurePower($1, -(fst $3), lhs parseState)
       else SynType.MeasurePower($1, fst $3, lhs parseState)  }
  | appTypeCon 
    { $1 }

appType:  
  | LBRACK appType RBRACK
      {
        let Position = lhs parseState
        SynType.App(SynType.LongIdent(LongIdentWithDots([Ident("list", Position)], [])),
                    None, [$2], [], None, true, Position)
      }  
  | appType arrayTypeSuffix 
      {  SynType.Array($2,$1,lhs parseState) }
  | appType HIGH_PRECEDENCE_BRACK_APP arrayTypeSuffix   /* only HPA for "name[]" allowed here */
      {  SynType.Array($3,$1,lhs parseState) }
  | appType appTypeConPower  
      { SynType.App($2, None, [$1], [], None, true, unionRanges (rhs parseState 1) $2.Range) }  /* note: use "rhs parseState 1" to deal with parens in "(int) list" */
  | LPAREN appTypePrefixArguments rparen  appTypeConPower
      { let args, commas = $2
        mlCompatWarning (FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated()) (unionRanges (rhs parseState 1) $4.Range); 
        SynType.App($4, None, args, commas, None, true, unionRanges (rhs parseState 1) $4.Range) }
  | powerType 
      { $1 }

arrayTypeSuffix:
  | LBRACK RBRACK 
      { 1 }
  | LBRACK COMMA RBRACK 
      { 2 }
  | LBRACK COMMA COMMA RBRACK 
      { 3 }
  | LBRACK COMMA COMMA COMMA RBRACK 
      { 4 }

appTypePrefixArguments:
  | typeArgActual COMMA typeArgActual typeArgListElements 
      { let typeArgs, commas = $4 in $1 :: $3 :: List.rev typeArgs, (rhs parseState 2)::(List.rev commas) }

typeArgListElements: 
  | typeArgListElements COMMA typeArgActual
      { let typeArgs, commas = $1
        $3 :: typeArgs, (rhs parseState 2)::commas } 
  |   
      { [], [] }

powerType:
  | atomType
    { $1 }
  | atomType INFIX_AT_HAT_OP INT32
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       if $2 = "^-" then SynType.MeasurePower($1, - (fst $3), lhs parseState)
       else SynType.MeasurePower($1, fst $3, lhs parseState) }
  | atomType INFIX_AT_HAT_OP MINUS INT32
     { if $2 <> "^" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       SynType.MeasurePower($1, - (fst $4), lhs parseState) }

/* Like appType but gives a deprecation error when a non-atomic type is used */
appTypeNonAtomicDeprecated:
  | appType arrayTypeSuffix 
      {  deprecatedWithError (FSComp.SR.parsNonAtomicType()) (lhs parseState);
         SynType.Array($2,$1,lhs parseState) }
  | appType HIGH_PRECEDENCE_BRACK_APP arrayTypeSuffix   /* only HPA for "name[]" allowed here */
      {  deprecatedWithError (FSComp.SR.parsNonAtomicType()) (lhs parseState);
         SynType.Array($3,$1,lhs parseState) }
  | appType appTypeConPower  
      { let mWhole = unionRanges (rhs parseState 1) $2.Range  // note: use "rhs parseState 1" to deal with parens in "(int) list"
        deprecatedWithError (FSComp.SR.parsNonAtomicType()) mWhole;
        SynType.App($2, None, [$1], [], None, true, mWhole) }
  | LPAREN appTypePrefixArguments rparen  appTypeConPower
      { let args, commas = $2
        mlCompatWarning (FSComp.SR.parsMultiArgumentGenericTypeFormDeprecated()) (unionRanges (rhs parseState 1) $4.Range); 
        SynType.App($4, None, args, commas, None, true, unionRanges (rhs parseState 1) $4.Range) }
  | powerTypeNonAtomicDeprecated 
      { $1 }

/* Like powerType but gives a deprecation warning if a non-atomic type is used */
powerTypeNonAtomicDeprecated:
  | atomType
    { $1 }
  | atomType INFIX_AT_HAT_OP INT32
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       deprecatedWithError (FSComp.SR.parsNonAtomicType()) (lhs parseState);
       if $2 = "^-" then SynType.MeasurePower($1, - (fst $3), lhs parseState)
       else SynType.MeasurePower($1, fst $3, lhs parseState) }
  | atomType INFIX_AT_HAT_OP MINUS INT32
     { if $2 <> "^" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedInfixOperator());
       deprecatedWithError (FSComp.SR.parsNonAtomicType()) (lhs parseState);
       SynType.MeasurePower($1, - (fst $4), lhs parseState) }


/* Any tokens in this grammar must be added to the lex filter rule 'peekAdjacentTypars' */
/* See the F# specification "Lexical analysis of type applications and type parameter definitions" */
atomType:
  | appTypeConPower %prec prec_atomtyp_path 
     { $1 }
  | UNDERSCORE 
     { SynType.Anon (lhs parseState) }
  | LPAREN typ rparen 
     {  $2 }
  | LPAREN typ recover      
     { reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnmatchedParen()) 
       $2 }  
  | rawConstant 
     { SynType.StaticConstant($1, rhs parseState 1) }
  | NULL
     { let m = rhs parseState 1
       SynType.StaticConstant(SynConst.String (null, m), m) }
  | FALSE  
      { SynType.StaticConstant(SynConst.Bool false,lhs parseState) } 
  | TRUE  
      { SynType.StaticConstant(SynConst.Bool true,lhs parseState) } 
  | LPAREN error rparen   
     { (* silent recovery *) SynType.Anon (lhs parseState) }  
  | appTypeCon typeArgsNoHpaDeprecated %prec prec_atomtyp_path 
     { let mLessThan,mGreaterThan,args,commas,mWhole = $2 in SynType.App($1, Some(mLessThan), args, commas, mGreaterThan, false, unionRanges $1.Range mWhole) } 
  | appTypeCon DOT ends_coming_soon_or_recover
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedNameAfterToken())
       $1 } 


typeArgsNoHpaDeprecated:
  | typeArgsActual
     { let mLessThan, mGreaterThan, parsedOk, args, commas, mAll = $1
       if parsedOk then // if someone has "foo<bar" without a closing greater-than, then the lexfilter does not introduce a HPA, even though it is adjacent
           warning(Error(FSComp.SR.parsNonAdjacentTyargs(),rhs parseState 1))
       mLessThan, mGreaterThan, args, commas, mAll } 
  | HIGH_PRECEDENCE_TYAPP typeArgsActual 
     { let mLessThan, mGreaterThan, _, args, commas, mAll = $2
       mLessThan, mGreaterThan, args, commas, mAll } 

typeArgsActual:
  | LESS typeArgActualOrDummyIfEmpty COMMA typeArgActualOrDummyIfEmpty typeArgListElements GREATER 
     { let typeArgs, commas = $5
       (rhs parseState 1), Some(rhs parseState 6), true, ($2 :: $4 :: List.rev typeArgs), (rhs parseState 3)::(List.rev commas), lhs parseState } 
  | LESS typeArgActualOrDummyIfEmpty COMMA typeArgActualOrDummyIfEmpty typeArgListElements recover
     { if not $6 then 
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedEndOfFileTypeArgs())
       else
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMissingGreaterThan())
       let typeArgs, commas = $5
       let nextToken = rhs parseState 6
       let zeroWidthAtStartOfNextToken = nextToken
       (rhs parseState 1), None, false, ($2 :: $4 :: List.rev typeArgs), (rhs parseState 3)::(List.rev commas), unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

  | LESS typeArgActualOrDummyIfEmpty COMMA ends_coming_soon_or_recover
     { if not $4 then reportParseErrorAt (rhs parseState 4) (FSComp.SR.parsMissingTypeArgs())
       let nextToken = rhs parseState 4
       let zeroWidthAtStartOfNextToken = nextToken
       (rhs parseState 1), None, false, [$2], [rhs parseState 3], unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

  | LESS typeArgActual GREATER 
     { (rhs parseState 1), Some(rhs parseState 3), true, [$2], [], lhs parseState } 
  | LESS typeArgActual recover
     { if not $3 then 
           reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsUnexpectedEndOfFileTypeArgs())
       else
           reportParseErrorAt (rhs parseState 3) (FSComp.SR.parsMissingGreaterThan())
       (rhs parseState 1), None, false, [$2], [], (rhs2 parseState 1 2) } 

  | LESS GREATER 
     { (rhs parseState 1), Some(rhs parseState 2), true, [], [], lhs parseState } 
  | LESS recover
     { if not $2 then  
           reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsExpectedTypeAfterToken())
       else
           reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsMissingTypeArgs())
       let nextToken = rhs parseState 2
       let zeroWidthAtStartOfNextToken = nextToken
       (rhs parseState 1), None, false, [], [], unionRanges (rhs parseState 1) zeroWidthAtStartOfNextToken } 

typeArgActual:
  | typ
     { $1 }

typeArgActualOrDummyIfEmpty:
  | typeArgActual
     { $1 }


measureTypeArg:
  | LESS measureTypeExpr GREATER
     { $2 }
  | LESS UNDERSCORE GREATER
     { SynMeasure.Anon (lhs parseState) }

measureTypeAtom:
  | path 
     { SynMeasure.Named($1.Lid, $1.Range) }

  | LPAREN measureTypeExpr rparen
     { $2 }

measureTypePower:
  | measureTypeAtom 
      { $1 }

  | measureTypeAtom INFIX_AT_HAT_OP INT32
     { if $2 <> "^" && $2 <> "^-" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
       if $2 = "^-" then SynMeasure.Power($1, - (fst $3), lhs parseState)
       else SynMeasure.Power($1, fst $3, lhs parseState) }

  | measureTypeAtom INFIX_AT_HAT_OP MINUS INT32
     { if $2 <> "^" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
       SynMeasure.Power($1, - (fst $4), lhs parseState) }

  | INT32
     { if fst $1 <> 1 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedIntegerLiteralForUnitOfMeasure());
       SynMeasure.One }

measureTypeSeq:
  | measureTypePower
    { [$1] }
  | measureTypePower measureTypeSeq
    { $1 :: $2 }

measureTypeExpr:
  | measureTypeSeq
    { SynMeasure.Seq($1, lhs parseState) }
  | measureTypeExpr STAR measureTypeExpr
    { SynMeasure.Product($1, $3, lhs parseState) }
  | measureTypeExpr INFIX_STAR_DIV_MOD_OP measureTypeExpr
    { if $2 <> "*" && $2 <> "/" then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
      if $2 = "*" then SynMeasure.Product($1, $3, lhs parseState)
      else SynMeasure.Divide($1, $3, lhs parseState) }
  | INFIX_STAR_DIV_MOD_OP measureTypeExpr
     { if $1 <> "/" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedOperatorForUnitOfMeasure());
       SynMeasure.Divide(SynMeasure.One, $2, lhs parseState) }
   
typar: 
  | QUOTE ident 
     {  let id = mkSynId (lhs parseState) ($2).idText
        Typar(id ,NoStaticReq,false) }
  | staticallyKnownHeadTypar 
     { $1 }

staticallyKnownHeadTypar: 
  | INFIX_AT_HAT_OP ident 
    {  if $1 <> "^" then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsUnexpectedTypeParameter());
       Typar($2,HeadTypeStaticReq,false) }

  

ident: 
  | IDENT 
     { ident($1,rhs parseState 1) } 

path: 
  | GLOBAL
      { LongIdentWithDots([ident(MangledGlobalName,rhs parseState 1)],[]) }
  | CREATE  
     {  LongIdentWithDots([Ident("Create", rhs parseState 1)],[]) }
  | ident  
     {  LongIdentWithDots([$1],[]) }  
  | path DOT ident  
     { let (LongIdentWithDots(lid,dotms)) = $1 in LongIdentWithDots(lid @ [$3], dotms @ [rhs parseState 2]) } 
  | path DOT ends_coming_soon_or_recover  
     { if not $3 then reportParseErrorAt (rhs parseState 2) (FSComp.SR.parsExpectedNameAfterToken())
       let (LongIdentWithDots(lid,dotms)) = $1 in LongIdentWithDots(lid, dotms @ [rhs parseState 2])  } 

opName: 
  | LPAREN operatorName rparen  
     {  ident(CompileOpName $2,rhs parseState 2) }
  | LPAREN error rparen  
     {  reportParseErrorAt (lhs parseState) (FSComp.SR.parsErrorParsingAsOperatorName()); ident(CompileOpName "****",rhs parseState 2) }
  | LPAREN_STAR_RPAREN
     {  ident(CompileOpName "*",rhs parseState 1) }

/* active pattern value names */
  | LPAREN barNames BAR rparen 
     { let text = ("|"^String.concat "|" (List.rev $2) ^ "|")
       ident(text,rhs2 parseState 2 3) }
                         
  | LPAREN barNames BAR UNDERSCORE BAR rparen 
     { let text = ("|"^String.concat "|" (List.rev $2) ^ ".|" )
       ident(text,rhs2 parseState 2 5) }

operatorName: 
  | PREFIX_OP 
      { if not (IsValidPrefixOperatorDefinitionName $1) then 
            reportParseErrorAt (lhs parseState) (FSComp.SR.parsInvalidPrefixOperatorDefinition());
        $1 }
  | INFIX_STAR_STAR_OP  { $1 }
  | INFIX_COMPARE_OP { $1 }
  | INFIX_AT_HAT_OP  { $1 }
  | INFIX_BAR_OP  { $1 }
  | INFIX_AMP_OP { $1 }
  | PLUS_MINUS_OP  { $1 }
  | INFIX_STAR_DIV_MOD_OP { $1 }
  | DOLLAR { "$" }
  | ADJACENT_PREFIX_OP { $1 }
  | MINUS { "-" }
  | STAR { "*" }
  | EQUALS { "=" }
  | OR { "or" }
  | LESS { "<" }
  | GREATER { ">" }
  | QMARK { "?" }
  | AMP { "&" }
  | AMP_AMP { "&&" }
  | BAR_BAR { "||" }
  | COLON_EQUALS { ":=" }
  | FUNKY_OPERATOR_NAME 
      { if $1 <> ".[]"  && $1 <> ".()" && $1 <> ".()<-" then 
             deprecatedOperator (lhs parseState); 
        $1 }
  | PERCENT_OP { $1 }
  | DOT_DOT { ".." }
  | DOT_DOT DOT_DOT { ".. .." }
  | LQUOTE RQUOTE 
      { if $1 <> $2 then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsMismatchedQuotationName(fst $1));  
        fst $1 } 

barName: 
  | IDENT 
      { if not (isUpper $1) then reportParseErrorAt (rhs parseState 1) (FSComp.SR.parsActivePatternCaseMustBeginWithUpperCase());  
        $1 }

barNames: 
  | BAR barName
      { [$2] }
  | barNames BAR barName
      { $3 :: $1 }

identOrOp: 
  | ident  
     { $1 } 
  | opName 
     { $1 }

/* path ending in an op */
/* note, only used in atomicPatternLongIdent */
pathOp: 
  | ident  
     {  LongIdentWithDots([$1],[]) }
  | opName 
     {  LongIdentWithDots([$1],[]) }
  | CREATE
     {  LongIdentWithDots([Ident("Create", rhs parseState 1)],[]) }
  | ident DOT pathOp 
     { let (LongIdentWithDots(lid,dotms)) = $3 
       LongIdentWithDots($1 :: lid, rhs parseState 2 :: dotms) } 
  | ident DOT error  
     { (* silent recovery *) LongIdentWithDots([$1],[rhs parseState 2]) }  


/* nameop is identOrOp not used as part of a path */
nameop: 
  | identOrOp  { $1 } 

topSeparator: 
  | SEMICOLON { } 
  | SEMICOLON_SEMICOLON { }
  | OBLOCKSEP { }  

topSeparators: 
  | topSeparator                     { } 
  | topSeparator topSeparators { }

interactiveSeparator: 
  | SEMICOLON { } 
  | OBLOCKSEP { }  

interactiveSeparators: 
  | interactiveSeparator                     { } 
  | interactiveSeparator interactiveSeparators { }

opt_interactiveSeparators: 
  | interactiveSeparator opt_interactiveSeparators { }
  |                        { } 

opt_topSeparators: 
  | topSeparator opt_topSeparators { }
  |                      { } 

seps: 
  | OBLOCKSEP { } 
  | SEMICOLON { }
  | OBLOCKSEP SEMICOLON { }
  | SEMICOLON OBLOCKSEP { }

/* An 'end' that's optional only in #light, where an ODECLEND gets inserted, and explicit 'end's get converted to OEND */
declEnd: 
  | ODECLEND 
      { } 
  | OEND 
      {   }
  | END 
      {} 

/* An 'end' that's optional in both #light and #heavy */
opt_declEnd: 
  | ODECLEND 
      {} 
  | OEND 
      { } 
  | END 
      {} 
  |     
      {} 

opt_ODECLEND: 
  | ODECLEND { } 
  |          { }

deprecated_opt_equals: 
  | EQUALS    { deprecatedWithError (FSComp.SR.parsNoEqualShouldFollowNamespace()) (lhs parseState); () } 
  |           {  }

opt_OBLOCKSEP: 
  | OBLOCKSEP { }
  |          { } 

opt_seps: 
  | seps { }
  |      { } 

opt_rec: 
  | REC { true }
  |     { false } 

opt_bar: 
  | BAR { } 
  |     { } 

opt_inline: 
  | INLINE { 0 } 
  | MASTER { 1 } 
  | SLAVE { 2 } 
  | CONNECT { 3 } 
  |        { 4 }

opt_mutable: 
  | MUTABLE { true } 
  |         { false }

opt_ref: 
  | REFERENCE { true } 
  |           { false }

doToken: 
  | DO  { }
  | ODO { }

doneDeclEnd: 
  | DONE { }
  | ODECLEND { }  /* DONE gets thrown away by the lexfilter in favour of ODECLEND */

structOrBegin: 
  | STRUCT { mlCompatWarning (FSComp.SR.parsSyntaxModuleStructEndDeprecated()) (lhs parseState); }
  | BEGIN { } 

sigOrBegin: 
  | SIG { mlCompatWarning (FSComp.SR.parsSyntaxModuleSigEndDeprecated()) (lhs parseState); }
  | BEGIN { } 

colonOrEquals: 
  | COLON { mlCompatWarning (FSComp.SR.parsSyntaxModuleSigEndDeprecated()) (lhs parseState); }
  | EQUALS { } 

opt_HASH: 
  | HASH {} 

opt_HIGH_PRECEDENCE_APP:
  | HIGH_PRECEDENCE_BRACK_APP { }
  | HIGH_PRECEDENCE_PAREN_APP { }
  |    { }

opt_HIGH_PRECEDENCE_TYAPP:
  | HIGH_PRECEDENCE_TYAPP { }
  |    { }

type_keyword:
  | TYPE_COMING_SOON type_keyword { $2 }
  | TYPE_IS_HERE { false }
  | TYPE { false }
  | WORLD_ENTITY { true }
  | ENTITY { false }

module_keyword:
  | MODULE_COMING_SOON module_keyword { }
  | MODULE_IS_HERE { }
  | MODULE { }

rbrace:
  | RBRACE_COMING_SOON rbrace { }
  | RBRACE_IS_HERE { }
  | RBRACE { }

rparen:
  | RPAREN_COMING_SOON rparen { }
  | RPAREN_IS_HERE { }
  | RPAREN { }

oblockend:
  | OBLOCKEND_COMING_SOON oblockend { }
  | OBLOCKEND_IS_HERE { }
  | OBLOCKEND { }

ends_other_than_rparen_coming_soon_or_recover:
  | TYPE_COMING_SOON { false }
  | MODULE_COMING_SOON { false }
  | RBRACE_COMING_SOON { false }
  | OBLOCKEND_COMING_SOON { false }
  | recover { $1 }

ends_coming_soon_or_recover:
  | TYPE_COMING_SOON { false }
  | MODULE_COMING_SOON { false }
  | RBRACE_COMING_SOON { false }
  | RPAREN_COMING_SOON { false }
  | OBLOCKEND_COMING_SOON { false }
  | recover { $1 }